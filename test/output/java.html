<html><head>
	<title>java测试</title>
	<link rel="stylesheet" type="text/css" href="./../FlyHighLighter.css" />
	</head>
	<body><fieldset class="code"><legend>Java 代码</legend><pre><ol class="code_list"><li><span class="comment">/*</span></li><li><span class="comment"> * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.</span></li><li><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> *</span></li><li><span class="comment"> */</span></li><li></li><li><span class="keyword">package</span> java.lang;</li><li></li><li><span class="keyword">import</span> java.io.ObjectStreamField;</li><li><span class="keyword">import</span> java.io.UnsupportedEncodingException;</li><li><span class="keyword">import</span> java.nio.charset.Charset;</li><li><span class="keyword">import</span> java.util.<span class="builtin_func">ArrayList</span>;</li><li><span class="keyword">import</span> java.util.<span class="builtin_func">Arrays</span>;</li><li><span class="keyword">import</span> java.util.Comparator;</li><li><span class="keyword">import</span> java.util.Formatter;</li><li><span class="keyword">import</span> java.util.Locale;</li><li><span class="keyword">import</span> java.util.Objects;</li><li><span class="keyword">import</span> java.util.StringJoiner;</li><li><span class="keyword">import</span> java.util.regex.Matcher;</li><li><span class="keyword">import</span> java.util.regex.Pattern;</li><li><span class="keyword">import</span> java.util.regex.PatternSyntaxException;</li><li></li><li><span class="doc">/**</span></li><li><span class="doc"> * The {@code String} class represents character strings. All</span></li><li><span class="doc"> * string literals in Java programs, such as {@code &quot;abc&quot;}, are</span></li><li><span class="doc"> * implemented as instances of this class.</span></li><li><span class="doc"> * &lt;p&gt;</span></li><li><span class="doc"> * Strings are constant; their values cannot be changed after they</span></li><li><span class="doc"> * are created. String buffers support mutable strings.</span></li><li><span class="doc"> * Because String objects are immutable they can be shared. For example:</span></li><li><span class="doc"> * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc"> *     String str = &quot;abc&quot;;</span></li><li><span class="doc"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;</span></li><li><span class="doc"> * is equivalent to:</span></li><li><span class="doc"> * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc"> *     char data[] = {'a', 'b', 'c'};</span></li><li><span class="doc"> *     String str = new String(data);</span></li><li><span class="doc"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;</span></li><li><span class="doc"> * Here are some more examples of how strings can be used:</span></li><li><span class="doc"> * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc"> *     System.out.println(&quot;abc&quot;);</span></li><li><span class="doc"> *     String cde = &quot;cde&quot;;</span></li><li><span class="doc"> *     System.out.println(&quot;abc&quot; + cde);</span></li><li><span class="doc"> *     String c = &quot;abc&quot;.substring(2,3);</span></li><li><span class="doc"> *     String d = cde.substring(1, 2);</span></li><li><span class="doc"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc"> * &lt;p&gt;</span></li><li><span class="doc"> * The class {@code String} includes methods for examining</span></li><li><span class="doc"> * individual characters of the sequence, for comparing strings, for</span></li><li><span class="doc"> * searching strings, for extracting substrings, and for creating a</span></li><li><span class="doc"> * copy of a string with all characters translated to uppercase or to</span></li><li><span class="doc"> * lowercase. Case mapping is based on the Unicode Standard version</span></li><li><span class="doc"> * specified by the {@link java.lang.Character Character} class.</span></li><li><span class="doc"> * &lt;p&gt;</span></li><li><span class="doc"> * The Java language provides special support for the string</span></li><li><span class="doc"> * concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of</span></li><li><span class="doc"> * other objects to strings. String concatenation is implemented</span></li><li><span class="doc"> * through the {@code StringBuilder}(or {@code StringBuffer})</span></li><li><span class="doc"> * class and its {@code append} method.</span></li><li><span class="doc"> * String conversions are implemented through the method</span></li><li><span class="doc"> * {@code toString}, defined by {@code Object} and</span></li><li><span class="doc"> * inherited by all classes in Java. For additional information on</span></li><li><span class="doc"> * string concatenation and conversion, see Gosling, Joy, and Steele,</span></li><li><span class="doc"> * &lt;i&gt;The Java Language Specification&lt;/i&gt;.</span></li><li><span class="doc"> *</span></li><li><span class="doc"> * &lt;p&gt; Unless otherwise noted, passing a &lt;tt&gt;null&lt;/tt&gt; argument to a constructor</span></li><li><span class="doc"> * or method in this class will cause a {@link NullPointerException} to be</span></li><li><span class="doc"> * thrown.</span></li><li><span class="doc"> *</span></li><li><span class="doc"> * &lt;p&gt;A {@code String} represents a string in the UTF-16 format</span></li><li><span class="doc"> * in which &lt;em&gt;supplementary characters&lt;/em&gt; are represented by &lt;em&gt;surrogate</span></li><li><span class="doc"> * pairs&lt;/em&gt; (see the section &lt;a href=&quot;Character.html&#35;unicode&quot;&gt;Unicode</span></li><li><span class="doc"> * Character Representations&lt;/a&gt; in the {@code Character} class for</span></li><li><span class="doc"> * more information).</span></li><li><span class="doc"> * Index values refer to {@code char} code units, so a supplementary</span></li><li><span class="doc"> * character uses two positions in a {@code String}.</span></li><li><span class="doc"> * &lt;p&gt;The {@code String} class provides methods for dealing with</span></li><li><span class="doc"> * Unicode code points (i.e., characters), in addition to those for</span></li><li><span class="doc"> * dealing with Unicode code units (i.e., {@code char} values).</span></li><li><span class="doc"> *</span></li><li><span class="doc"> * @author  Lee Boynton</span></li><li><span class="doc"> * @author  Arthur van Hoff</span></li><li><span class="doc"> * @author  Martin Buchholz</span></li><li><span class="doc"> * @author  Ulf Zibis</span></li><li><span class="doc"> * @see     java.lang.Object&#35;toString()</span></li><li><span class="doc"> * @see     java.lang.StringBuffer</span></li><li><span class="doc"> * @see     java.lang.StringBuilder</span></li><li><span class="doc"> * @see     java.nio.charset.Charset</span></li><li><span class="doc"> * @since   JDK1.0</span></li><li><span class="doc"> */</span></li><li></li><li><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="builtin_func">String</span></li><li>    <span class="keyword">implements</span> java.io.Serializable, Comparable<span class="bracket"><</span><span class="builtin_func">String</span><span class="bracket">></span>, CharSequence <span class="bracket">{</span></li><li>    <span class="doc">/** The value is used for character storage. */</span></li><li>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value<span class="bracket">[</span><span class="bracket">]</span>;</li><li></li><li>    <span class="doc">/** Cache the hash code for the string */</span></li><li>    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></li><li></li><li>    <span class="doc">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></li><li>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Class String is special cased within the Serialization Stream Protocol.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * A String instance is written into an ObjectOutputStream according to</span></li><li><span class="doc">     * &lt;a href=&quot;{@docRoot}/../platform/serialization/spec/output.html&quot;&gt;</span></li><li><span class="doc">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField<span class="bracket">[</span><span class="bracket">]</span> serialPersistentFields =</li><li>        <span class="keyword">new</span> ObjectStreamField<span class="bracket">[</span><span class="number">0</span><span class="bracket">]</span>;</li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Initializes a newly created {@code String} object so that it represents</span></li><li><span class="doc">     * an empty character sequence.  Note that use of this constructor is</span></li><li><span class="doc">     * unnecessary since Strings are immutable.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Initializes a newly created {@code String} object so that it represents</span></li><li><span class="doc">     * the same sequence of characters as the argument; in other words, the</span></li><li><span class="doc">     * newly created string is a copy of the argument string. Unless an</span></li><li><span class="doc">     * explicit copy of {@code original} is needed, use of this constructor is</span></li><li><span class="doc">     * unnecessary since Strings are immutable.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  original</span></li><li><span class="doc">     *         A {@code String}</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="builtin_func">String</span> original<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span>.value = original.value;</li><li>        <span class="keyword">this</span>.hash = original.hash;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new {@code String} so that it represents the sequence of</span></li><li><span class="doc">     * characters currently contained in the character array argument. The</span></li><li><span class="doc">     * contents of the character array are copied; subsequent modification of</span></li><li><span class="doc">     * the character array does not affect the newly created string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  value</span></li><li><span class="doc">     *         The initial value of the string</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">char</span> value<span class="bracket">[</span><span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span>.value = <span class="builtin_func">Arrays</span>.copyOf<span class="bracket">(</span>value, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new {@code String} that contains characters from a subarray</span></li><li><span class="doc">     * of the character array argument. The {@code offset} argument is the</span></li><li><span class="doc">     * index of the first character of the subarray and the {@code count}</span></li><li><span class="doc">     * argument specifies the length of the subarray. The contents of the</span></li><li><span class="doc">     * subarray are copied; subsequent modification of the character array does</span></li><li><span class="doc">     * not affect the newly created string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  value</span></li><li><span class="doc">     *         Array that is the source of characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  offset</span></li><li><span class="doc">     *         The initial offset</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  count</span></li><li><span class="doc">     *         The length</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If the {@code offset} and {@code count} arguments index</span></li><li><span class="doc">     *          characters outside the bounds of the {@code value} array</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">char</span> value<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> offset, <span class="keyword">int</span> count<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>offset<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>count <span class="bracket"><</span>= <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>count <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>count<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket"><</span>= value.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</li><li>                <span class="keyword">return</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket">></span> value.length - count<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>offset + count<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">this</span>.value = <span class="builtin_func">Arrays</span>.copyOfRange<span class="bracket">(</span>value, offset, offset+count<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new {@code String} that contains characters from a subarray</span></li><li><span class="doc">     * of the &lt;a href=&quot;Character.html&#35;unicode&quot;&gt;Unicode code point&lt;/a&gt; array</span></li><li><span class="doc">     * argument.  The {@code offset} argument is the index of the first code</span></li><li><span class="doc">     * point of the subarray and the {@code count} argument specifies the</span></li><li><span class="doc">     * length of the subarray.  The contents of the subarray are converted to</span></li><li><span class="doc">     * {@code char}s; subsequent modification of the {@code int} array does not</span></li><li><span class="doc">     * affect the newly created string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  codePoints</span></li><li><span class="doc">     *         Array that is the source of Unicode code points</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  offset</span></li><li><span class="doc">     *         The initial offset</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  count</span></li><li><span class="doc">     *         The length</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IllegalArgumentException</span></li><li><span class="doc">     *          If any invalid Unicode code point is found in {@code</span></li><li><span class="doc">     *          codePoints}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If the {@code offset} and {@code count} arguments index</span></li><li><span class="doc">     *          characters outside the bounds of the {@code codePoints} array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">int</span><span class="bracket">[</span><span class="bracket">]</span> codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>offset<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>count <span class="bracket"><</span>= <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>count <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>count<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket"><</span>= codePoints.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</li><li>                <span class="keyword">return</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket">></span> codePoints.length - count<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>offset + count<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</li><li></li><li>        <span class="comment">// Pass 1: Compute precise size of char[]</span></li><li>        <span class="keyword">int</span> n = count;</li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = offset; i <span class="bracket"><</span> end; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">int</span> c = codePoints<span class="bracket">[</span>i<span class="bracket">]</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span><span class="builtin_func">Character</span>.isBmpCodePoint<span class="bracket">(</span>c<span class="bracket">)</span><span class="bracket">)</span></li><li>                <span class="keyword">continue</span>;</li><li>            <span class="keyword">else</span> <span class="keyword">if</span> <span class="bracket">(</span><span class="builtin_func">Character</span>.isValidCodePoint<span class="bracket">(</span>c<span class="bracket">)</span><span class="bracket">)</span></li><li>                n++;</li><li>            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">IllegalArgumentException</span><span class="bracket">(</span><span class="builtin_func">Integer</span>.toString<span class="bracket">(</span>c<span class="bracket">)</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="comment">// Pass 2: Allocate and fill in char[]</span></li><li>        <span class="keyword">final</span> <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> v = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>n<span class="bracket">]</span>;</li><li></li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i <span class="bracket"><</span> end; i++, j++<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">int</span> c = codePoints<span class="bracket">[</span>i<span class="bracket">]</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span><span class="builtin_func">Character</span>.isBmpCodePoint<span class="bracket">(</span>c<span class="bracket">)</span><span class="bracket">)</span></li><li>                v<span class="bracket">[</span>j<span class="bracket">]</span> = <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>c;</li><li>            <span class="keyword">else</span></li><li>                <span class="builtin_func">Character</span>.toSurrogates<span class="bracket">(</span>c, v, j++<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">this</span>.value = v;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new {@code String} constructed from a subarray of an array</span></li><li><span class="doc">     * of 8-bit integer values.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The {@code offset} argument is the index of the first byte of the</span></li><li><span class="doc">     * subarray, and the {@code count} argument specifies the length of the</span></li><li><span class="doc">     * subarray.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; Each {@code byte} in the subarray is converted to a {@code char} as</span></li><li><span class="doc">     * specified in the method above.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @deprecated This method does not properly convert bytes into characters.</span></li><li><span class="doc">     * As of JDK&amp;nbsp;1.1, the preferred way to do this is via the</span></li><li><span class="doc">     * {@code String} constructors that take a {@link</span></li><li><span class="doc">     * java.nio.charset.Charset}, charset name, or that use the platform's</span></li><li><span class="doc">     * default charset.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  ascii</span></li><li><span class="doc">     *         The bytes to be converted to characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  hibyte</span></li><li><span class="doc">     *         The top 8 bits of each 16-bit Unicode code unit</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  offset</span></li><li><span class="doc">     *         The initial offset</span></li><li><span class="doc">     * @param  count</span></li><li><span class="doc">     *         The length</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If the {@code offset} or {@code count} argument is invalid</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see  &#35;String(byte[], int)</span></li><li><span class="doc">     * @see  &#35;String(byte[], int, int, java.lang.String)</span></li><li><span class="doc">     * @see  &#35;String(byte[], int, int, java.nio.charset.Charset)</span></li><li><span class="doc">     * @see  &#35;String(byte[], int, int)</span></li><li><span class="doc">     * @see  &#35;String(byte[], java.lang.String)</span></li><li><span class="doc">     * @see  &#35;String(byte[], java.nio.charset.Charset)</span></li><li><span class="doc">     * @see  &#35;String(byte[])</span></li><li><span class="doc">     */</span></li><li>    <span class="annotation">@Deprecated</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> ascii<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> hibyte, <span class="keyword">int</span> offset, <span class="keyword">int</span> count<span class="bracket">)</span> <span class="bracket">{</span></li><li>        checkBounds<span class="bracket">(</span>ascii, offset, count<span class="bracket">)</span>;</li><li>        <span class="keyword">char</span> value<span class="bracket">[</span><span class="bracket">]</span> = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>count<span class="bracket">]</span>;</li><li></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>hibyte == <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = count; i-- <span class="bracket">></span> <span class="number">0</span>;<span class="bracket">)</span> <span class="bracket">{</span></li><li>                value<span class="bracket">[</span>i<span class="bracket">]</span> = <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span><span class="bracket">(</span>ascii<span class="bracket">[</span>i + offset<span class="bracket">]</span> & <span class="number">0xff</span><span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>            hibyte <span class="bracket"><</span><span class="bracket"><</span>= <span class="number">8</span>;</li><li>            <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = count; i-- <span class="bracket">></span> <span class="number">0</span>;<span class="bracket">)</span> <span class="bracket">{</span></li><li>                value<span class="bracket">[</span>i<span class="bracket">]</span> = <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span><span class="bracket">(</span>hibyte | <span class="bracket">(</span>ascii<span class="bracket">[</span>i + offset<span class="bracket">]</span> & <span class="number">0xff</span><span class="bracket">)</span><span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">this</span>.value = value;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new {@code String} containing characters constructed from</span></li><li><span class="doc">     * an array of 8-bit integer values. Each character &lt;i&gt;c&lt;/i&gt;in the</span></li><li><span class="doc">     * resulting string is constructed from the corresponding component</span></li><li><span class="doc">     * &lt;i&gt;b&lt;/i&gt; in the byte array such that:</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     *     &lt;b&gt;&lt;i&gt;c&lt;/i&gt;&lt;/b&gt; == (char)(((hibyte &amp;amp; 0xff) &amp;lt;&amp;lt; 8)</span></li><li><span class="doc">     *                         | (&lt;b&gt;&lt;i&gt;b&lt;/i&gt;&lt;/b&gt; &amp;amp; 0xff))</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @deprecated  This method does not properly convert bytes into</span></li><li><span class="doc">     * characters.  As of JDK&amp;nbsp;1.1, the preferred way to do this is via the</span></li><li><span class="doc">     * {@code String} constructors that take a {@link</span></li><li><span class="doc">     * java.nio.charset.Charset}, charset name, or that use the platform's</span></li><li><span class="doc">     * default charset.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  ascii</span></li><li><span class="doc">     *         The bytes to be converted to characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  hibyte</span></li><li><span class="doc">     *         The top 8 bits of each 16-bit Unicode code unit</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see  &#35;String(byte[], int, int, java.lang.String)</span></li><li><span class="doc">     * @see  &#35;String(byte[], int, int, java.nio.charset.Charset)</span></li><li><span class="doc">     * @see  &#35;String(byte[], int, int)</span></li><li><span class="doc">     * @see  &#35;String(byte[], java.lang.String)</span></li><li><span class="doc">     * @see  &#35;String(byte[], java.nio.charset.Charset)</span></li><li><span class="doc">     * @see  &#35;String(byte[])</span></li><li><span class="doc">     */</span></li><li>    <span class="annotation">@Deprecated</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> ascii<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> hibyte<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span><span class="bracket">(</span>ascii, hibyte, <span class="number">0</span>, ascii.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="comment">/* Common private utility method used to bounds check the byte array</span></li><li><span class="comment">     * and requested offset &amp; length values used by the String(byte[],..)</span></li><li><span class="comment">     * constructors.</span></li><li><span class="comment">     */</span></li><li>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> checkBounds<span class="bracket">(</span><span class="keyword">byte</span><span class="bracket">[</span><span class="bracket">]</span> bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>length <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>length<span class="bracket">)</span>;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>offset<span class="bracket">)</span>;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>offset <span class="bracket">></span> bytes.length - length<span class="bracket">)</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>offset + length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Constructs a new {@code String} by decoding the specified subarray of</span></li><li><span class="doc">     * bytes using the specified charset.  The length of the new {@code String}</span></li><li><span class="doc">     * is a function of the charset, and hence may not be equal to the length</span></li><li><span class="doc">     * of the subarray.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The behavior of this constructor when the given bytes are not valid</span></li><li><span class="doc">     * in the given charset is unspecified.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetDecoder} class should be used when more control</span></li><li><span class="doc">     * over the decoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  bytes</span></li><li><span class="doc">     *         The bytes to be decoded into characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  offset</span></li><li><span class="doc">     *         The index of the first byte to decode</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  length</span></li><li><span class="doc">     *         The number of bytes to decode</span></li><li><span class="doc"></span></li><li><span class="doc">     * @param  charsetName</span></li><li><span class="doc">     *         The name of a supported {@linkplain java.nio.charset.Charset</span></li><li><span class="doc">     *         charset}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  UnsupportedEncodingException</span></li><li><span class="doc">     *          If the named charset is not supported</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If the {@code offset} and {@code length} arguments index</span></li><li><span class="doc">     *          characters outside the bounds of the {@code bytes} array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  JDK1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> bytes<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="builtin_func">String</span> charsetName<span class="bracket">)</span></li><li>            <span class="keyword">throws</span> UnsupportedEncodingException <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>charsetName == <span class="keyword">null</span><span class="bracket">)</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">NullPointerException</span><span class="bracket">(</span><span class="string">&quot;charsetName&quot;</span><span class="bracket">)</span>;</li><li>        checkBounds<span class="bracket">(</span>bytes, offset, length<span class="bracket">)</span>;</li><li>        <span class="keyword">this</span>.value = StringCoding.decode<span class="bracket">(</span>charsetName, bytes, offset, length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Constructs a new {@code String} by decoding the specified subarray of</span></li><li><span class="doc">     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.</span></li><li><span class="doc">     * The length of the new {@code String} is a function of the charset, and</span></li><li><span class="doc">     * hence may not be equal to the length of the subarray.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; This method always replaces malformed-input and unmappable-character</span></li><li><span class="doc">     * sequences with this charset's default replacement string.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetDecoder} class should be used when more control</span></li><li><span class="doc">     * over the decoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  bytes</span></li><li><span class="doc">     *         The bytes to be decoded into characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  offset</span></li><li><span class="doc">     *         The index of the first byte to decode</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  length</span></li><li><span class="doc">     *         The number of bytes to decode</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  charset</span></li><li><span class="doc">     *         The {@linkplain java.nio.charset.Charset charset} to be used to</span></li><li><span class="doc">     *         decode the {@code bytes}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If the {@code offset} and {@code length} arguments index</span></li><li><span class="doc">     *          characters outside the bounds of the {@code bytes} array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.6</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> bytes<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>charset == <span class="keyword">null</span><span class="bracket">)</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">NullPointerException</span><span class="bracket">(</span><span class="string">&quot;charset&quot;</span><span class="bracket">)</span>;</li><li>        checkBounds<span class="bracket">(</span>bytes, offset, length<span class="bracket">)</span>;</li><li>        <span class="keyword">this</span>.value =  StringCoding.decode<span class="bracket">(</span>charset, bytes, offset, length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Constructs a new {@code String} by decoding the specified array of bytes</span></li><li><span class="doc">     * using the specified {@linkplain java.nio.charset.Charset charset}.  The</span></li><li><span class="doc">     * length of the new {@code String} is a function of the charset, and hence</span></li><li><span class="doc">     * may not be equal to the length of the byte array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The behavior of this constructor when the given bytes are not valid</span></li><li><span class="doc">     * in the given charset is unspecified.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetDecoder} class should be used when more control</span></li><li><span class="doc">     * over the decoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  bytes</span></li><li><span class="doc">     *         The bytes to be decoded into characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  charsetName</span></li><li><span class="doc">     *         The name of a supported {@linkplain java.nio.charset.Charset</span></li><li><span class="doc">     *         charset}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  UnsupportedEncodingException</span></li><li><span class="doc">     *          If the named charset is not supported</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  JDK1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> bytes<span class="bracket">[</span><span class="bracket">]</span>, <span class="builtin_func">String</span> charsetName<span class="bracket">)</span></li><li>            <span class="keyword">throws</span> UnsupportedEncodingException <span class="bracket">{</span></li><li>        <span class="keyword">this</span><span class="bracket">(</span>bytes, <span class="number">0</span>, bytes.length, charsetName<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Constructs a new {@code String} by decoding the specified array of</span></li><li><span class="doc">     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.</span></li><li><span class="doc">     * The length of the new {@code String} is a function of the charset, and</span></li><li><span class="doc">     * hence may not be equal to the length of the byte array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; This method always replaces malformed-input and unmappable-character</span></li><li><span class="doc">     * sequences with this charset's default replacement string.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetDecoder} class should be used when more control</span></li><li><span class="doc">     * over the decoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  bytes</span></li><li><span class="doc">     *         The bytes to be decoded into characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  charset</span></li><li><span class="doc">     *         The {@linkplain java.nio.charset.Charset charset} to be used to</span></li><li><span class="doc">     *         decode the {@code bytes}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.6</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> bytes<span class="bracket">[</span><span class="bracket">]</span>, Charset charset<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span><span class="bracket">(</span>bytes, <span class="number">0</span>, bytes.length, charset<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Constructs a new {@code String} by decoding the specified subarray of</span></li><li><span class="doc">     * bytes using the platform's default charset.  The length of the new</span></li><li><span class="doc">     * {@code String} is a function of the charset, and hence may not be equal</span></li><li><span class="doc">     * to the length of the subarray.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The behavior of this constructor when the given bytes are not valid</span></li><li><span class="doc">     * in the default charset is unspecified.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetDecoder} class should be used when more control</span></li><li><span class="doc">     * over the decoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  bytes</span></li><li><span class="doc">     *         The bytes to be decoded into characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  offset</span></li><li><span class="doc">     *         The index of the first byte to decode</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  length</span></li><li><span class="doc">     *         The number of bytes to decode</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If the {@code offset} and the {@code length} arguments index</span></li><li><span class="doc">     *          characters outside the bounds of the {@code bytes} array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  JDK1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> bytes<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> offset, <span class="keyword">int</span> length<span class="bracket">)</span> <span class="bracket">{</span></li><li>        checkBounds<span class="bracket">(</span>bytes, offset, length<span class="bracket">)</span>;</li><li>        <span class="keyword">this</span>.value = StringCoding.decode<span class="bracket">(</span>bytes, offset, length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Constructs a new {@code String} by decoding the specified array of bytes</span></li><li><span class="doc">     * using the platform's default charset.  The length of the new {@code</span></li><li><span class="doc">     * String} is a function of the charset, and hence may not be equal to the</span></li><li><span class="doc">     * length of the byte array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The behavior of this constructor when the given bytes are not valid</span></li><li><span class="doc">     * in the default charset is unspecified.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetDecoder} class should be used when more control</span></li><li><span class="doc">     * over the decoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  bytes</span></li><li><span class="doc">     *         The bytes to be decoded into characters</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  JDK1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">byte</span> bytes<span class="bracket">[</span><span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span><span class="bracket">(</span>bytes, <span class="number">0</span>, bytes.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new string that contains the sequence of characters</span></li><li><span class="doc">     * currently contained in the string buffer argument. The contents of the</span></li><li><span class="doc">     * string buffer are copied; subsequent modification of the string buffer</span></li><li><span class="doc">     * does not affect the newly created string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  buffer</span></li><li><span class="doc">     *         A {@code StringBuffer}</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="builtin_func">StringBuffer</span> buffer<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">synchronized</span><span class="bracket">(</span>buffer<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">this</span>.value = <span class="builtin_func">Arrays</span>.copyOf<span class="bracket">(</span>buffer.getValue<span class="bracket">(</span><span class="bracket">)</span>, buffer.length<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Allocates a new string that contains the sequence of characters</span></li><li><span class="doc">     * currently contained in the string builder argument. The contents of the</span></li><li><span class="doc">     * string builder are copied; subsequent modification of the string builder</span></li><li><span class="doc">     * does not affect the newly created string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; This constructor is provided to ease migration to {@code</span></li><li><span class="doc">     * StringBuilder}. Obtaining a string from a string builder via the {@code</span></li><li><span class="doc">     * toString} method is likely to run faster and is generally preferred.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   builder</span></li><li><span class="doc">     *          A {@code StringBuilder}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">(</span><span class="builtin_func">StringBuilder</span> builder<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">this</span>.value = <span class="builtin_func">Arrays</span>.copyOf<span class="bracket">(</span>builder.getValue<span class="bracket">(</span><span class="bracket">)</span>, builder.length<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="comment">/*</span></li><li><span class="comment">    * Package private constructor which shares value array for speed.</span></li><li><span class="comment">    * this constructor is always expected to be called with share==true.</span></li><li><span class="comment">    * a separate constructor is needed because we already have a public</span></li><li><span class="comment">    * String(char[]) constructor that makes a copy of the given char[].</span></li><li><span class="comment">    */</span></li><li>    <span class="builtin_func">String</span><span class="bracket">(</span><span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> value, <span class="keyword">boolean</span> share<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="comment">// assert share : &quot;unshared not supported&quot;;</span></li><li>        <span class="keyword">this</span>.value = value;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the length of this string.</span></li><li><span class="doc">     * The length is equal to the number of &lt;a href=&quot;Character.html&#35;unicode&quot;&gt;Unicode</span></li><li><span class="doc">     * code units&lt;/a&gt; in the string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  the length of the sequence of characters represented by this</span></li><li><span class="doc">     *          object.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> length<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> value.length;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns {@code true} if, and only if, {@link &#35;length()} is {@code 0}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return {@code true} if {@link &#35;length()} is {@code 0}, otherwise</span></li><li><span class="doc">     * {@code false}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.6</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> value.length == <span class="number">0</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the {@code char} value at the</span></li><li><span class="doc">     * specified index. An index ranges from {@code 0} to</span></li><li><span class="doc">     * {@code length() - 1}. The first {@code char} value of the sequence</span></li><li><span class="doc">     * is at index {@code 0}, the next at index {@code 1},</span></li><li><span class="doc">     * and so on, as for array indexing.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;If the {@code char} value specified by the index is a</span></li><li><span class="doc">     * &lt;a href=&quot;Character.html&#35;unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate</span></li><li><span class="doc">     * value is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param      index   the index of the {@code char} value.</span></li><li><span class="doc">     * @return     the {@code char} value at the specified index of this string.</span></li><li><span class="doc">     *             The first {@code char} value is at index {@code 0}.</span></li><li><span class="doc">     * @exception  IndexOutOfBoundsException  if the {@code index}</span></li><li><span class="doc">     *             argument is negative or not less than the length of this</span></li><li><span class="doc">     *             string.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">char</span> charAt<span class="bracket">(</span><span class="keyword">int</span> index<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>index <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>index <span class="bracket">></span>= value.length<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>index<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> value<span class="bracket">[</span>index<span class="bracket">]</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the character (Unicode code point) at the specified</span></li><li><span class="doc">     * index. The index refers to {@code char} values</span></li><li><span class="doc">     * (Unicode code units) and ranges from {@code 0} to</span></li><li><span class="doc">     * {@link &#35;length()}{@code  - 1}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; If the {@code char} value specified at the given index</span></li><li><span class="doc">     * is in the high-surrogate range, the following index is less</span></li><li><span class="doc">     * than the length of this {@code String}, and the</span></li><li><span class="doc">     * {@code char} value at the following index is in the</span></li><li><span class="doc">     * low-surrogate range, then the supplementary code point</span></li><li><span class="doc">     * corresponding to this surrogate pair is returned. Otherwise,</span></li><li><span class="doc">     * the {@code char} value at the given index is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param      index the index to the {@code char} values</span></li><li><span class="doc">     * @return     the code point value of the character at the</span></li><li><span class="doc">     *             {@code index}</span></li><li><span class="doc">     * @exception  IndexOutOfBoundsException  if the {@code index}</span></li><li><span class="doc">     *             argument is negative or not less than the length of this</span></li><li><span class="doc">     *             string.</span></li><li><span class="doc">     * @since      1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> codePointAt<span class="bracket">(</span><span class="keyword">int</span> index<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>index <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>index <span class="bracket">></span>= value.length<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>index<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Character</span>.codePointAtImpl<span class="bracket">(</span>value, index, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the character (Unicode code point) before the specified</span></li><li><span class="doc">     * index. The index refers to {@code char} values</span></li><li><span class="doc">     * (Unicode code units) and ranges from {@code 1} to {@link</span></li><li><span class="doc">     * CharSequence&#35;length() length}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; If the {@code char} value at {@code (index - 1)}</span></li><li><span class="doc">     * is in the low-surrogate range, {@code (index - 2)} is not</span></li><li><span class="doc">     * negative, and the {@code char} value at {@code (index -</span></li><li><span class="doc">     * 2)} is in the high-surrogate range, then the</span></li><li><span class="doc">     * supplementary code point value of the surrogate pair is</span></li><li><span class="doc">     * returned. If the {@code char} value at {@code index -</span></li><li><span class="doc">     * 1} is an unpaired low-surrogate or a high-surrogate, the</span></li><li><span class="doc">     * surrogate value is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param     index the index following the code point that should be returned</span></li><li><span class="doc">     * @return    the Unicode code point value before the given index.</span></li><li><span class="doc">     * @exception IndexOutOfBoundsException if the {@code index}</span></li><li><span class="doc">     *            argument is less than 1 or greater than the length</span></li><li><span class="doc">     *            of this string.</span></li><li><span class="doc">     * @since     1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> codePointBefore<span class="bracket">(</span><span class="keyword">int</span> index<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">int</span> i = index - <span class="number">1</span>;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>i <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>i <span class="bracket">></span>= value.length<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>index<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Character</span>.codePointBeforeImpl<span class="bracket">(</span>value, index, <span class="number">0</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the number of Unicode code points in the specified text</span></li><li><span class="doc">     * range of this {@code String}. The text range begins at the</span></li><li><span class="doc">     * specified {@code beginIndex} and extends to the</span></li><li><span class="doc">     * {@code char} at index {@code endIndex - 1}. Thus the</span></li><li><span class="doc">     * length (in {@code char}s) of the text range is</span></li><li><span class="doc">     * {@code endIndex-beginIndex}. Unpaired surrogates within</span></li><li><span class="doc">     * the text range count as one code point each.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param beginIndex the index to the first {@code char} of</span></li><li><span class="doc">     * the text range.</span></li><li><span class="doc">     * @param endIndex the index after the last {@code char} of</span></li><li><span class="doc">     * the text range.</span></li><li><span class="doc">     * @return the number of Unicode code points in the specified text</span></li><li><span class="doc">     * range</span></li><li><span class="doc">     * @exception IndexOutOfBoundsException if the</span></li><li><span class="doc">     * {@code beginIndex} is negative, or {@code endIndex}</span></li><li><span class="doc">     * is larger than the length of this {@code String}, or</span></li><li><span class="doc">     * {@code beginIndex} is larger than {@code endIndex}.</span></li><li><span class="doc">     * @since  1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> codePointCount<span class="bracket">(</span><span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>beginIndex <span class="bracket"><</span> <span class="number">0</span> || endIndex <span class="bracket">></span> value.length || beginIndex <span class="bracket">></span> endIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">IndexOutOfBoundsException</span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Character</span>.codePointCountImpl<span class="bracket">(</span>value, beginIndex, endIndex - beginIndex<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this {@code String} that is</span></li><li><span class="doc">     * offset from the given {@code index} by</span></li><li><span class="doc">     * {@code codePointOffset} code points. Unpaired surrogates</span></li><li><span class="doc">     * within the text range given by {@code index} and</span></li><li><span class="doc">     * {@code codePointOffset} count as one code point each.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param index the index to be offset</span></li><li><span class="doc">     * @param codePointOffset the offset in code points</span></li><li><span class="doc">     * @return the index within this {@code String}</span></li><li><span class="doc">     * @exception IndexOutOfBoundsException if {@code index}</span></li><li><span class="doc">     *   is negative or larger then the length of this</span></li><li><span class="doc">     *   {@code String}, or if {@code codePointOffset} is positive</span></li><li><span class="doc">     *   and the substring starting with {@code index} has fewer</span></li><li><span class="doc">     *   than {@code codePointOffset} code points,</span></li><li><span class="doc">     *   or if {@code codePointOffset} is negative and the substring</span></li><li><span class="doc">     *   before {@code index} has fewer than the absolute value</span></li><li><span class="doc">     *   of {@code codePointOffset} code points.</span></li><li><span class="doc">     * @since 1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> offsetByCodePoints<span class="bracket">(</span><span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>index <span class="bracket"><</span> <span class="number">0</span> || index <span class="bracket">></span> value.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">IndexOutOfBoundsException</span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Character</span>.offsetByCodePointsImpl<span class="bracket">(</span>value, <span class="number">0</span>, value.length,</li><li>                index, codePointOffset<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Copy characters from this string into dst starting at dstBegin.</span></li><li><span class="doc">     * This method doesn't perform any range checking.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">void</span> getChars<span class="bracket">(</span><span class="keyword">char</span> dst<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> dstBegin<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>value, <span class="number">0</span>, dst, dstBegin, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Copies characters from this string into the destination character</span></li><li><span class="doc">     * array.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * The first character to be copied is at index {@code srcBegin};</span></li><li><span class="doc">     * the last character to be copied is at index {@code srcEnd-1}</span></li><li><span class="doc">     * (thus the total number of characters to be copied is</span></li><li><span class="doc">     * {@code srcEnd-srcBegin}). The characters are copied into the</span></li><li><span class="doc">     * subarray of {@code dst} starting at index {@code dstBegin}</span></li><li><span class="doc">     * and ending at index:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     *     dstBegin + (srcEnd-srcBegin) - 1</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param      srcBegin   index of the first character in the string</span></li><li><span class="doc">     *                        to copy.</span></li><li><span class="doc">     * @param      srcEnd     index after the last character in the string</span></li><li><span class="doc">     *                        to copy.</span></li><li><span class="doc">     * @param      dst        the destination array.</span></li><li><span class="doc">     * @param      dstBegin   the start offset in the destination array.</span></li><li><span class="doc">     * @exception IndexOutOfBoundsException If any of the following</span></li><li><span class="doc">     *            is true:</span></li><li><span class="doc">     *            &lt;ul&gt;&lt;li&gt;{@code srcBegin} is negative.</span></li><li><span class="doc">     *            &lt;li&gt;{@code srcBegin} is greater than {@code srcEnd}</span></li><li><span class="doc">     *            &lt;li&gt;{@code srcEnd} is greater than the length of this</span></li><li><span class="doc">     *                string</span></li><li><span class="doc">     *            &lt;li&gt;{@code dstBegin} is negative</span></li><li><span class="doc">     *            &lt;li&gt;{@code dstBegin+(srcEnd-srcBegin)} is larger than</span></li><li><span class="doc">     *                {@code dst.length}&lt;/ul&gt;</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">void</span> getChars<span class="bracket">(</span><span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> dstBegin<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>srcBegin <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>srcBegin<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>srcEnd <span class="bracket">></span> value.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>srcEnd<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>srcBegin <span class="bracket">></span> srcEnd<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>srcEnd - srcBegin<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>value, srcBegin, dst, dstBegin, srcEnd - srcBegin<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Copies characters from this string into the destination byte array. Each</span></li><li><span class="doc">     * byte receives the 8 low-order bits of the corresponding character. The</span></li><li><span class="doc">     * eight high-order bits of each character are not copied and do not</span></li><li><span class="doc">     * participate in the transfer in any way.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The first character to be copied is at index {@code srcBegin}; the</span></li><li><span class="doc">     * last character to be copied is at index {@code srcEnd-1}.  The total</span></li><li><span class="doc">     * number of characters to be copied is {@code srcEnd-srcBegin}. The</span></li><li><span class="doc">     * characters, converted to bytes, are copied into the subarray of {@code</span></li><li><span class="doc">     * dst} starting at index {@code dstBegin} and ending at index:</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     *     dstBegin + (srcEnd-srcBegin) - 1</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @deprecated  This method does not properly convert characters into</span></li><li><span class="doc">     * bytes.  As of JDK&amp;nbsp;1.1, the preferred way to do this is via the</span></li><li><span class="doc">     * {@link &#35;getBytes()} method, which uses the platform's default charset.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  srcBegin</span></li><li><span class="doc">     *         Index of the first character in the string to copy</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  srcEnd</span></li><li><span class="doc">     *         Index after the last character in the string to copy</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  dst</span></li><li><span class="doc">     *         The destination array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  dstBegin</span></li><li><span class="doc">     *         The start offset in the destination array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          If any of the following is true:</span></li><li><span class="doc">     *          &lt;ul&gt;</span></li><li><span class="doc">     *            &lt;li&gt; {@code srcBegin} is negative</span></li><li><span class="doc">     *            &lt;li&gt; {@code srcBegin} is greater than {@code srcEnd}</span></li><li><span class="doc">     *            &lt;li&gt; {@code srcEnd} is greater than the length of this String</span></li><li><span class="doc">     *            &lt;li&gt; {@code dstBegin} is negative</span></li><li><span class="doc">     *            &lt;li&gt; {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code</span></li><li><span class="doc">     *                 dst.length}</span></li><li><span class="doc">     *          &lt;/ul&gt;</span></li><li><span class="doc">     */</span></li><li>    <span class="annotation">@Deprecated</span></li><li>    <span class="keyword">public</span> <span class="keyword">void</span> getBytes<span class="bracket">(</span><span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">byte</span> dst<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> dstBegin<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>srcBegin <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>srcBegin<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>srcEnd <span class="bracket">></span> value.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>srcEnd<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>srcBegin <span class="bracket">></span> srcEnd<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>srcEnd - srcBegin<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        Objects.requireNonNull<span class="bracket">(</span>dst<span class="bracket">)</span>;</li><li></li><li>        <span class="keyword">int</span> j = dstBegin;</li><li>        <span class="keyword">int</span> n = srcEnd;</li><li>        <span class="keyword">int</span> i = srcBegin;</li><li>        <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> val = value;   <span class="comment">/* avoid getfield opcode */</span></li><li></li><li>        <span class="keyword">while</span> <span class="bracket">(</span>i <span class="bracket"><</span> n<span class="bracket">)</span> <span class="bracket">{</span></li><li>            dst<span class="bracket">[</span>j++<span class="bracket">]</span> = <span class="bracket">(</span><span class="keyword">byte</span><span class="bracket">)</span>val<span class="bracket">[</span>i++<span class="bracket">]</span>;</li><li>        <span class="bracket">}</span></li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Encodes this {@code String} into a sequence of bytes using the named</span></li><li><span class="doc">     * charset, storing the result into a new byte array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The behavior of this method when this string cannot be encoded in</span></li><li><span class="doc">     * the given charset is unspecified.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetEncoder} class should be used when more control</span></li><li><span class="doc">     * over the encoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  charsetName</span></li><li><span class="doc">     *         The name of a supported {@linkplain java.nio.charset.Charset</span></li><li><span class="doc">     *         charset}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  The resultant byte array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  UnsupportedEncodingException</span></li><li><span class="doc">     *          If the named charset is not supported</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  JDK1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">byte</span><span class="bracket">[</span><span class="bracket">]</span> getBytes<span class="bracket">(</span><span class="builtin_func">String</span> charsetName<span class="bracket">)</span></li><li>            <span class="keyword">throws</span> UnsupportedEncodingException <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>charsetName == <span class="keyword">null</span><span class="bracket">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">NullPointerException</span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="keyword">return</span> StringCoding.encode<span class="bracket">(</span>charsetName, value, <span class="number">0</span>, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Encodes this {@code String} into a sequence of bytes using the given</span></li><li><span class="doc">     * {@linkplain java.nio.charset.Charset charset}, storing the result into a</span></li><li><span class="doc">     * new byte array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; This method always replaces malformed-input and unmappable-character</span></li><li><span class="doc">     * sequences with this charset's default replacement byte array.  The</span></li><li><span class="doc">     * {@link java.nio.charset.CharsetEncoder} class should be used when more</span></li><li><span class="doc">     * control over the encoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  charset</span></li><li><span class="doc">     *         The {@linkplain java.nio.charset.Charset} to be used to encode</span></li><li><span class="doc">     *         the {@code String}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  The resultant byte array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.6</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">byte</span><span class="bracket">[</span><span class="bracket">]</span> getBytes<span class="bracket">(</span>Charset charset<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>charset == <span class="keyword">null</span><span class="bracket">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">NullPointerException</span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="keyword">return</span> StringCoding.encode<span class="bracket">(</span>charset, value, <span class="number">0</span>, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Encodes this {@code String} into a sequence of bytes using the</span></li><li><span class="doc">     * platform's default charset, storing the result into a new byte array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The behavior of this method when this string cannot be encoded in</span></li><li><span class="doc">     * the default charset is unspecified.  The {@link</span></li><li><span class="doc">     * java.nio.charset.CharsetEncoder} class should be used when more control</span></li><li><span class="doc">     * over the encoding process is required.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  The resultant byte array</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since      JDK1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">byte</span><span class="bracket">[</span><span class="bracket">]</span> getBytes<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> StringCoding.encode<span class="bracket">(</span>value, <span class="number">0</span>, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Compares this string to the specified object.  The result is {@code</span></li><li><span class="doc">     * true} if and only if the argument is not {@code null} and is a {@code</span></li><li><span class="doc">     * String} object that represents the same sequence of characters as this</span></li><li><span class="doc">     * object.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  anObject</span></li><li><span class="doc">     *         The object to compare this {@code String} against</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  {@code true} if the given object represents a {@code String}</span></li><li><span class="doc">     *          equivalent to this string, {@code false} otherwise</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see  &#35;compareTo(String)</span></li><li><span class="doc">     * @see  &#35;equalsIgnoreCase(String)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> equals<span class="bracket">(</span><span class="builtin_func">Object</span> anObject<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="keyword">this</span> == anObject<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>anObject <span class="keyword">instanceof</span> <span class="builtin_func">String</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="builtin_func">String</span> anotherString = <span class="bracket">(</span><span class="builtin_func">String</span><span class="bracket">)</span>anObject;</li><li>            <span class="keyword">int</span> n = value.length;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span>n == anotherString.value.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">char</span> v1<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>                <span class="keyword">char</span> v2<span class="bracket">[</span><span class="bracket">]</span> = anotherString.value;</li><li>                <span class="keyword">int</span> i = <span class="number">0</span>;</li><li>                <span class="keyword">while</span> <span class="bracket">(</span>n-- != <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">if</span> <span class="bracket">(</span>v1<span class="bracket">[</span>i<span class="bracket">]</span> != v2<span class="bracket">[</span>i<span class="bracket">]</span><span class="bracket">)</span></li><li>                        <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>                    i++;</li><li>                <span class="bracket">}</span></li><li>                <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Compares this string to the specified {@code StringBuffer}.  The result</span></li><li><span class="doc">     * is {@code true} if and only if this {@code String} represents the same</span></li><li><span class="doc">     * sequence of characters as the specified {@code StringBuffer}. This method</span></li><li><span class="doc">     * synchronizes on the {@code StringBuffer}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  sb</span></li><li><span class="doc">     *         The {@code StringBuffer} to compare this {@code String} against</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  {@code true} if this {@code String} represents the same</span></li><li><span class="doc">     *          sequence of characters as the specified {@code StringBuffer},</span></li><li><span class="doc">     *          {@code false} otherwise</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.4</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> contentEquals<span class="bracket">(</span><span class="builtin_func">StringBuffer</span> sb<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> contentEquals<span class="bracket">(</span><span class="bracket">(</span>CharSequence<span class="bracket">)</span>sb<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="keyword">private</span> <span class="keyword">boolean</span> nonSyncContentEquals<span class="bracket">(</span>AbstractStringBuilder sb<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">char</span> v1<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>        <span class="keyword">char</span> v2<span class="bracket">[</span><span class="bracket">]</span> = sb.getValue<span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="keyword">int</span> n = v1.length;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>n != sb.length<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = <span class="number">0</span>; i <span class="bracket"><</span> n; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>v1<span class="bracket">[</span>i<span class="bracket">]</span> != v2<span class="bracket">[</span>i<span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Compares this string to the specified {@code CharSequence}.  The</span></li><li><span class="doc">     * result is {@code true} if and only if this {@code String} represents the</span></li><li><span class="doc">     * same sequence of char values as the specified sequence. Note that if the</span></li><li><span class="doc">     * {@code CharSequence} is a {@code StringBuffer} then the method</span></li><li><span class="doc">     * synchronizes on it.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  cs</span></li><li><span class="doc">     *         The sequence to compare this {@code String} against</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  {@code true} if this {@code String} represents the same</span></li><li><span class="doc">     *          sequence of char values as the specified sequence, {@code</span></li><li><span class="doc">     *          false} otherwise</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since  1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> contentEquals<span class="bracket">(</span>CharSequence cs<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="comment">// Argument is a StringBuffer, StringBuilder</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>cs <span class="keyword">instanceof</span> AbstractStringBuilder<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>cs <span class="keyword">instanceof</span> <span class="builtin_func">StringBuffer</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">synchronized</span><span class="bracket">(</span>cs<span class="bracket">)</span> <span class="bracket">{</span></li><li>                   <span class="keyword">return</span> nonSyncContentEquals<span class="bracket">(</span><span class="bracket">(</span>AbstractStringBuilder<span class="bracket">)</span>cs<span class="bracket">)</span>;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> nonSyncContentEquals<span class="bracket">(</span><span class="bracket">(</span>AbstractStringBuilder<span class="bracket">)</span>cs<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="comment">// Argument is a String</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>cs <span class="keyword">instanceof</span> <span class="builtin_func">String</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> equals<span class="bracket">(</span>cs<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="comment">// Argument is a generic CharSequence</span></li><li>        <span class="keyword">char</span> v1<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>        <span class="keyword">int</span> n = v1.length;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>n != cs.length<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = <span class="number">0</span>; i <span class="bracket"><</span> n; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>v1<span class="bracket">[</span>i<span class="bracket">]</span> != cs.charAt<span class="bracket">(</span>i<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Compares this {@code String} to another {@code String}, ignoring case</span></li><li><span class="doc">     * considerations.  Two strings are considered equal ignoring case if they</span></li><li><span class="doc">     * are of the same length and corresponding characters in the two strings</span></li><li><span class="doc">     * are equal ignoring case.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; Two characters {@code c1} and {@code c2} are considered the same</span></li><li><span class="doc">     * ignoring case if at least one of the following is true:</span></li><li><span class="doc">     * &lt;ul&gt;</span></li><li><span class="doc">     *   &lt;li&gt; The two characters are the same (as compared by the</span></li><li><span class="doc">     *        {@code ==} operator)</span></li><li><span class="doc">     *   &lt;li&gt; Applying the method {@link</span></li><li><span class="doc">     *        java.lang.Character&#35;toUpperCase(char)} to each character</span></li><li><span class="doc">     *        produces the same result</span></li><li><span class="doc">     *   &lt;li&gt; Applying the method {@link</span></li><li><span class="doc">     *        java.lang.Character&#35;toLowerCase(char)} to each character</span></li><li><span class="doc">     *        produces the same result</span></li><li><span class="doc">     * &lt;/ul&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  anotherString</span></li><li><span class="doc">     *         The {@code String} to compare this {@code String} against</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  {@code true} if the argument is not {@code null} and it</span></li><li><span class="doc">     *          represents an equivalent {@code String} ignoring case; {@code</span></li><li><span class="doc">     *          false} otherwise</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see  &#35;equals(Object)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> equalsIgnoreCase<span class="bracket">(</span><span class="builtin_func">String</span> anotherString<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="bracket">(</span><span class="keyword">this</span> == anotherString<span class="bracket">)</span> ? <span class="keyword">true</span></li><li>                : <span class="bracket">(</span>anotherString != <span class="keyword">null</span><span class="bracket">)</span></li><li>                && <span class="bracket">(</span>anotherString.value.length == value.length<span class="bracket">)</span></li><li>                && regionMatches<span class="bracket">(</span><span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Compares two strings lexicographically.</span></li><li><span class="doc">     * The comparison is based on the Unicode value of each character in</span></li><li><span class="doc">     * the strings. The character sequence represented by this</span></li><li><span class="doc">     * {@code String} object is compared lexicographically to the</span></li><li><span class="doc">     * character sequence represented by the argument string. The result is</span></li><li><span class="doc">     * a negative integer if this {@code String} object</span></li><li><span class="doc">     * lexicographically precedes the argument string. The result is a</span></li><li><span class="doc">     * positive integer if this {@code String} object lexicographically</span></li><li><span class="doc">     * follows the argument string. The result is zero if the strings</span></li><li><span class="doc">     * are equal; {@code compareTo} returns {@code 0} exactly when</span></li><li><span class="doc">     * the {@link &#35;equals(Object)} method would return {@code true}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * This is the definition of lexicographic ordering. If two strings are</span></li><li><span class="doc">     * different, then either they have different characters at some index</span></li><li><span class="doc">     * that is a valid index for both strings, or their lengths are different,</span></li><li><span class="doc">     * or both. If they have different characters at one or more index</span></li><li><span class="doc">     * positions, let &lt;i&gt;k&lt;/i&gt; be the smallest such index; then the string</span></li><li><span class="doc">     * whose character at position &lt;i&gt;k&lt;/i&gt; has the smaller value, as</span></li><li><span class="doc">     * determined by using the &amp;lt; operator, lexicographically precedes the</span></li><li><span class="doc">     * other string. In this case, {@code compareTo} returns the</span></li><li><span class="doc">     * difference of the two character values at position {@code k} in</span></li><li><span class="doc">     * the two string -- that is, the value:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.charAt(k)-anotherString.charAt(k)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * If there is no index position at which they differ, then the shorter</span></li><li><span class="doc">     * string lexicographically precedes the longer string. In this case,</span></li><li><span class="doc">     * {@code compareTo} returns the difference of the lengths of the</span></li><li><span class="doc">     * strings -- that is, the value:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.length()-anotherString.length()</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   anotherString   the {@code String} to be compared.</span></li><li><span class="doc">     * @return  the value {@code 0} if the argument string is equal to</span></li><li><span class="doc">     *          this string; a value less than {@code 0} if this string</span></li><li><span class="doc">     *          is lexicographically less than the string argument; and a</span></li><li><span class="doc">     *          value greater than {@code 0} if this string is</span></li><li><span class="doc">     *          lexicographically greater than the string argument.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> compareTo<span class="bracket">(</span><span class="builtin_func">String</span> anotherString<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">int</span> len1 = value.length;</li><li>        <span class="keyword">int</span> len2 = anotherString.value.length;</li><li>        <span class="keyword">int</span> lim = <span class="builtin_func">Math</span>.min<span class="bracket">(</span>len1, len2<span class="bracket">)</span>;</li><li>        <span class="keyword">char</span> v1<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>        <span class="keyword">char</span> v2<span class="bracket">[</span><span class="bracket">]</span> = anotherString.value;</li><li></li><li>        <span class="keyword">int</span> k = <span class="number">0</span>;</li><li>        <span class="keyword">while</span> <span class="bracket">(</span>k <span class="bracket"><</span> lim<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">char</span> c1 = v1<span class="bracket">[</span>k<span class="bracket">]</span>;</li><li>            <span class="keyword">char</span> c2 = v2<span class="bracket">[</span>k<span class="bracket">]</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span>c1 != c2<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> c1 - c2;</li><li>            <span class="bracket">}</span></li><li>            k++;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> len1 - len2;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * A Comparator that orders {@code String} objects as by</span></li><li><span class="doc">     * {@code compareToIgnoreCase}. This comparator is serializable.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account,</span></li><li><span class="doc">     * and will result in an unsatisfactory ordering for certain locales.</span></li><li><span class="doc">     * The java.text package provides &lt;em&gt;Collators&lt;/em&gt; to allow</span></li><li><span class="doc">     * locale-sensitive ordering.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see     java.text.Collator&#35;compare(String, String)</span></li><li><span class="doc">     * @since   1.2</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator<span class="bracket"><</span><span class="builtin_func">String</span><span class="bracket">></span> CASE_INSENSITIVE_ORDER</li><li>                                         = <span class="keyword">new</span> CaseInsensitiveComparator<span class="bracket">(</span><span class="bracket">)</span>;</li><li>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> CaseInsensitiveComparator</li><li>            <span class="keyword">implements</span> Comparator<span class="bracket"><</span><span class="builtin_func">String</span><span class="bracket">></span>, java.io.Serializable <span class="bracket">{</span></li><li>        <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></li><li>        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</li><li></li><li>        <span class="keyword">public</span> <span class="keyword">int</span> compare<span class="bracket">(</span><span class="builtin_func">String</span> s1, <span class="builtin_func">String</span> s2<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">int</span> n1 = s1.length<span class="bracket">(</span><span class="bracket">)</span>;</li><li>            <span class="keyword">int</span> n2 = s2.length<span class="bracket">(</span><span class="bracket">)</span>;</li><li>            <span class="keyword">int</span> min = <span class="builtin_func">Math</span>.min<span class="bracket">(</span>n1, n2<span class="bracket">)</span>;</li><li>            <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = <span class="number">0</span>; i <span class="bracket"><</span> min; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">char</span> c1 = s1.charAt<span class="bracket">(</span>i<span class="bracket">)</span>;</li><li>                <span class="keyword">char</span> c2 = s2.charAt<span class="bracket">(</span>i<span class="bracket">)</span>;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span>c1 != c2<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    c1 = <span class="builtin_func">Character</span>.toUpperCase<span class="bracket">(</span>c1<span class="bracket">)</span>;</li><li>                    c2 = <span class="builtin_func">Character</span>.toUpperCase<span class="bracket">(</span>c2<span class="bracket">)</span>;</li><li>                    <span class="keyword">if</span> <span class="bracket">(</span>c1 != c2<span class="bracket">)</span> <span class="bracket">{</span></li><li>                        c1 = <span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>c1<span class="bracket">)</span>;</li><li>                        c2 = <span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>c2<span class="bracket">)</span>;</li><li>                        <span class="keyword">if</span> <span class="bracket">(</span>c1 != c2<span class="bracket">)</span> <span class="bracket">{</span></li><li>                            <span class="comment">// No overflow because of numeric promotion</span></li><li>                            <span class="keyword">return</span> c1 - c2;</li><li>                        <span class="bracket">}</span></li><li>                    <span class="bracket">}</span></li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> n1 - n2;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="doc">/** Replaces the de-serialized object. */</span></li><li>        <span class="keyword">private</span> <span class="builtin_func">Object</span> readResolve<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span> <span class="keyword">return</span> CASE_INSENSITIVE_ORDER; <span class="bracket">}</span></li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Compares two strings lexicographically, ignoring case</span></li><li><span class="doc">     * differences. This method returns an integer whose sign is that of</span></li><li><span class="doc">     * calling {@code compareTo} with normalized versions of the strings</span></li><li><span class="doc">     * where case differences have been eliminated by calling</span></li><li><span class="doc">     * {@code Character.toLowerCase(Character.toUpperCase(character))} on</span></li><li><span class="doc">     * each character.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,</span></li><li><span class="doc">     * and will result in an unsatisfactory ordering for certain locales.</span></li><li><span class="doc">     * The java.text package provides &lt;em&gt;collators&lt;/em&gt; to allow</span></li><li><span class="doc">     * locale-sensitive ordering.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   str   the {@code String} to be compared.</span></li><li><span class="doc">     * @return  a negative integer, zero, or a positive integer as the</span></li><li><span class="doc">     *          specified String is greater than, equal to, or less</span></li><li><span class="doc">     *          than this String, ignoring case considerations.</span></li><li><span class="doc">     * @see     java.text.Collator&#35;compare(String, String)</span></li><li><span class="doc">     * @since   1.2</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> compareToIgnoreCase<span class="bracket">(</span><span class="builtin_func">String</span> str<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> CASE_INSENSITIVE_ORDER.compare<span class="bracket">(</span><span class="keyword">this</span>, str<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Tests if two string regions are equal.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * A substring of this {@code String} object is compared to a substring</span></li><li><span class="doc">     * of the argument other. The result is true if these substrings</span></li><li><span class="doc">     * represent identical character sequences. The substring of this</span></li><li><span class="doc">     * {@code String} object to be compared begins at index {@code toffset}</span></li><li><span class="doc">     * and has length {@code len}. The substring of other to be compared</span></li><li><span class="doc">     * begins at index {@code ooffset} and has length {@code len}. The</span></li><li><span class="doc">     * result is {@code false} if and only if at least one of the following</span></li><li><span class="doc">     * is true:</span></li><li><span class="doc">     * &lt;ul&gt;&lt;li&gt;{@code toffset} is negative.</span></li><li><span class="doc">     * &lt;li&gt;{@code ooffset} is negative.</span></li><li><span class="doc">     * &lt;li&gt;{@code toffset+len} is greater than the length of this</span></li><li><span class="doc">     * {@code String} object.</span></li><li><span class="doc">     * &lt;li&gt;{@code ooffset+len} is greater than the length of the other</span></li><li><span class="doc">     * argument.</span></li><li><span class="doc">     * &lt;li&gt;There is some nonnegative integer &lt;i&gt;k&lt;/i&gt; less than {@code len}</span></li><li><span class="doc">     * such that:</span></li><li><span class="doc">     * {@code this.charAt(toffset + }&lt;i&gt;k&lt;/i&gt;{@code ) != other.charAt(ooffset + }</span></li><li><span class="doc">     * &lt;i&gt;k&lt;/i&gt;{@code )}</span></li><li><span class="doc">     * &lt;/ul&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   toffset   the starting offset of the subregion in this string.</span></li><li><span class="doc">     * @param   other     the string argument.</span></li><li><span class="doc">     * @param   ooffset   the starting offset of the subregion in the string</span></li><li><span class="doc">     *                    argument.</span></li><li><span class="doc">     * @param   len       the number of characters to compare.</span></li><li><span class="doc">     * @return  {@code true} if the specified subregion of this string</span></li><li><span class="doc">     *          exactly matches the specified subregion of the string argument;</span></li><li><span class="doc">     *          {@code false} otherwise.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> regionMatches<span class="bracket">(</span><span class="keyword">int</span> toffset, <span class="builtin_func">String</span> other, <span class="keyword">int</span> ooffset,</li><li>            <span class="keyword">int</span> len<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">char</span> ta<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>        <span class="keyword">int</span> to = toffset;</li><li>        <span class="keyword">char</span> pa<span class="bracket">[</span><span class="bracket">]</span> = other.value;</li><li>        <span class="keyword">int</span> po = ooffset;</li><li>        <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>ooffset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>toffset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span></li><li>                || <span class="bracket">(</span>toffset <span class="bracket">></span> <span class="bracket">(</span><span class="keyword">long</span><span class="bracket">)</span>value.length - len<span class="bracket">)</span></li><li>                || <span class="bracket">(</span>ooffset <span class="bracket">></span> <span class="bracket">(</span><span class="keyword">long</span><span class="bracket">)</span>other.value.length - len<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">while</span> <span class="bracket">(</span>len-- <span class="bracket">></span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>ta<span class="bracket">[</span>to++<span class="bracket">]</span> != pa<span class="bracket">[</span>po++<span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Tests if two string regions are equal.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * A substring of this {@code String} object is compared to a substring</span></li><li><span class="doc">     * of the argument {@code other}. The result is {@code true} if these</span></li><li><span class="doc">     * substrings represent character sequences that are the same, ignoring</span></li><li><span class="doc">     * case if and only if {@code ignoreCase} is true. The substring of</span></li><li><span class="doc">     * this {@code String} object to be compared begins at index</span></li><li><span class="doc">     * {@code toffset} and has length {@code len}. The substring of</span></li><li><span class="doc">     * {@code other} to be compared begins at index {@code ooffset} and</span></li><li><span class="doc">     * has length {@code len}. The result is {@code false} if and only if</span></li><li><span class="doc">     * at least one of the following is true:</span></li><li><span class="doc">     * &lt;ul&gt;&lt;li&gt;{@code toffset} is negative.</span></li><li><span class="doc">     * &lt;li&gt;{@code ooffset} is negative.</span></li><li><span class="doc">     * &lt;li&gt;{@code toffset+len} is greater than the length of this</span></li><li><span class="doc">     * {@code String} object.</span></li><li><span class="doc">     * &lt;li&gt;{@code ooffset+len} is greater than the length of the other</span></li><li><span class="doc">     * argument.</span></li><li><span class="doc">     * &lt;li&gt;{@code ignoreCase} is {@code false} and there is some nonnegative</span></li><li><span class="doc">     * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.charAt(toffset+k) != other.charAt(ooffset+k)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * &lt;li&gt;{@code ignoreCase} is {@code true} and there is some nonnegative</span></li><li><span class="doc">     * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * Character.toLowerCase(this.charAt(toffset+k)) !=</span></li><li><span class="doc">     Character.toLowerCase(other.charAt(ooffset+k))</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * and:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * Character.toUpperCase(this.charAt(toffset+k)) !=</span></li><li><span class="doc">     *         Character.toUpperCase(other.charAt(ooffset+k))</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * &lt;/ul&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   ignoreCase   if {@code true}, ignore case when comparing</span></li><li><span class="doc">     *                       characters.</span></li><li><span class="doc">     * @param   toffset      the starting offset of the subregion in this</span></li><li><span class="doc">     *                       string.</span></li><li><span class="doc">     * @param   other        the string argument.</span></li><li><span class="doc">     * @param   ooffset      the starting offset of the subregion in the string</span></li><li><span class="doc">     *                       argument.</span></li><li><span class="doc">     * @param   len          the number of characters to compare.</span></li><li><span class="doc">     * @return  {@code true} if the specified subregion of this string</span></li><li><span class="doc">     *          matches the specified subregion of the string argument;</span></li><li><span class="doc">     *          {@code false} otherwise. Whether the matching is exact</span></li><li><span class="doc">     *          or case insensitive depends on the {@code ignoreCase}</span></li><li><span class="doc">     *          argument.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> regionMatches<span class="bracket">(</span><span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</li><li>            <span class="builtin_func">String</span> other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">char</span> ta<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>        <span class="keyword">int</span> to = toffset;</li><li>        <span class="keyword">char</span> pa<span class="bracket">[</span><span class="bracket">]</span> = other.value;</li><li>        <span class="keyword">int</span> po = ooffset;</li><li>        <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>ooffset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>toffset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span></li><li>                || <span class="bracket">(</span>toffset <span class="bracket">></span> <span class="bracket">(</span><span class="keyword">long</span><span class="bracket">)</span>value.length - len<span class="bracket">)</span></li><li>                || <span class="bracket">(</span>ooffset <span class="bracket">></span> <span class="bracket">(</span><span class="keyword">long</span><span class="bracket">)</span>other.value.length - len<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">while</span> <span class="bracket">(</span>len-- <span class="bracket">></span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">char</span> c1 = ta<span class="bracket">[</span>to++<span class="bracket">]</span>;</li><li>            <span class="keyword">char</span> c2 = pa<span class="bracket">[</span>po++<span class="bracket">]</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span>c1 == c2<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">continue</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>ignoreCase<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="comment">// If characters don't match but case may be ignored,</span></li><li>                <span class="comment">// try converting both characters to uppercase.</span></li><li>                <span class="comment">// If the results match, then the comparison scan should</span></li><li>                <span class="comment">// continue.</span></li><li>                <span class="keyword">char</span> u1 = <span class="builtin_func">Character</span>.toUpperCase<span class="bracket">(</span>c1<span class="bracket">)</span>;</li><li>                <span class="keyword">char</span> u2 = <span class="builtin_func">Character</span>.toUpperCase<span class="bracket">(</span>c2<span class="bracket">)</span>;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span>u1 == u2<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">continue</span>;</li><li>                <span class="bracket">}</span></li><li>                <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></li><li>                <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></li><li>                <span class="comment">// conversion.  So we need to make one last check before</span></li><li>                <span class="comment">// exiting.</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span><span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>u1<span class="bracket">)</span> == <span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>u2<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">continue</span>;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Tests if the substring of this string beginning at the</span></li><li><span class="doc">     * specified index starts with the specified prefix.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   prefix    the prefix.</span></li><li><span class="doc">     * @param   toffset   where to begin looking in this string.</span></li><li><span class="doc">     * @return  {@code true} if the character sequence represented by the</span></li><li><span class="doc">     *          argument is a prefix of the substring of this object starting</span></li><li><span class="doc">     *          at index {@code toffset}; {@code false} otherwise.</span></li><li><span class="doc">     *          The result is {@code false} if {@code toffset} is</span></li><li><span class="doc">     *          negative or greater than the length of this</span></li><li><span class="doc">     *          {@code String} object; otherwise the result is the same</span></li><li><span class="doc">     *          as the result of the expression</span></li><li><span class="doc">     *          &lt;pre&gt;</span></li><li><span class="doc">     *          this.substring(toffset).startsWith(prefix)</span></li><li><span class="doc">     *          &lt;/pre&gt;</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> startsWith<span class="bracket">(</span><span class="builtin_func">String</span> prefix, <span class="keyword">int</span> toffset<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">char</span> ta<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li>        <span class="keyword">int</span> to = toffset;</li><li>        <span class="keyword">char</span> pa<span class="bracket">[</span><span class="bracket">]</span> = prefix.value;</li><li>        <span class="keyword">int</span> po = <span class="number">0</span>;</li><li>        <span class="keyword">int</span> pc = prefix.value.length;</li><li>        <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>toffset <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>toffset <span class="bracket">></span> value.length - pc<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">while</span> <span class="bracket">(</span>--pc <span class="bracket">></span>= <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>ta<span class="bracket">[</span>to++<span class="bracket">]</span> != pa<span class="bracket">[</span>po++<span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> <span class="keyword">false</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">true</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Tests if this string starts with the specified prefix.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   prefix   the prefix.</span></li><li><span class="doc">     * @return  {@code true} if the character sequence represented by the</span></li><li><span class="doc">     *          argument is a prefix of the character sequence represented by</span></li><li><span class="doc">     *          this string; {@code false} otherwise.</span></li><li><span class="doc">     *          Note also that {@code true} will be returned if the</span></li><li><span class="doc">     *          argument is an empty string or is equal to this</span></li><li><span class="doc">     *          {@code String} object as determined by the</span></li><li><span class="doc">     *          {@link &#35;equals(Object)} method.</span></li><li><span class="doc">     * @since   1. 0</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> startsWith<span class="bracket">(</span><span class="builtin_func">String</span> prefix<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> startsWith<span class="bracket">(</span>prefix, <span class="number">0</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Tests if this string ends with the specified suffix.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   suffix   the suffix.</span></li><li><span class="doc">     * @return  {@code true} if the character sequence represented by the</span></li><li><span class="doc">     *          argument is a suffix of the character sequence represented by</span></li><li><span class="doc">     *          this object; {@code false} otherwise. Note that the</span></li><li><span class="doc">     *          result will be {@code true} if the argument is the</span></li><li><span class="doc">     *          empty string or is equal to this {@code String} object</span></li><li><span class="doc">     *          as determined by the {@link &#35;equals(Object)} method.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> endsWith<span class="bracket">(</span><span class="builtin_func">String</span> suffix<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> startsWith<span class="bracket">(</span>suffix, value.length - suffix.value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a hash code for this string. The hash code for a</span></li><li><span class="doc">     * {@code String} object is computed as</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * using {@code int} arithmetic, where {@code s[i]} is the</span></li><li><span class="doc">     * &lt;i&gt;i&lt;/i&gt;th character of the string, {@code n} is the length of</span></li><li><span class="doc">     * the string, and {@code ^} indicates exponentiation.</span></li><li><span class="doc">     * (The hash value of the empty string is zero.)</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  a hash code value for this object.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> hashCode<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">int</span> h = hash;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>h == <span class="number">0</span> && value.length <span class="bracket">></span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">char</span> val<span class="bracket">[</span><span class="bracket">]</span> = value;</li><li></li><li>            <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = <span class="number">0</span>; i <span class="bracket"><</span> value.length; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>                h = <span class="number">31</span> * h + val<span class="bracket">[</span>i<span class="bracket">]</span>;</li><li>            <span class="bracket">}</span></li><li>            hash = h;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> h;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the first occurrence of</span></li><li><span class="doc">     * the specified character. If a character with value</span></li><li><span class="doc">     * {@code ch} occurs in the character sequence represented by</span></li><li><span class="doc">     * this {@code String} object, then the index (in Unicode</span></li><li><span class="doc">     * code units) of the first such occurrence is returned. For</span></li><li><span class="doc">     * values of {@code ch} in the range from 0 to 0xFFFF</span></li><li><span class="doc">     * (inclusive), this is the smallest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. For other values of {@code ch}, it is the</span></li><li><span class="doc">     * smallest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. In either case, if no such character occurs in this</span></li><li><span class="doc">     * string, then {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   ch   a character (Unicode code point).</span></li><li><span class="doc">     * @return  the index of the first occurrence of the character in the</span></li><li><span class="doc">     *          character sequence represented by this object, or</span></li><li><span class="doc">     *          {@code -1} if the character does not occur.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> indexOf<span class="bracket">(</span><span class="keyword">int</span> ch<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> indexOf<span class="bracket">(</span>ch, <span class="number">0</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the first occurrence of the</span></li><li><span class="doc">     * specified character, starting the search at the specified index.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * If a character with value {@code ch} occurs in the</span></li><li><span class="doc">     * character sequence represented by this {@code String}</span></li><li><span class="doc">     * object at an index no smaller than {@code fromIndex}, then</span></li><li><span class="doc">     * the index of the first such occurrence is returned. For values</span></li><li><span class="doc">     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),</span></li><li><span class="doc">     * this is the smallest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * (this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch) {@code &amp;&amp;} (&lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. For other values of {@code ch}, it is the</span></li><li><span class="doc">     * smallest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * (this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch) {@code &amp;&amp;} (&lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. In either case, if no such character occurs in this</span></li><li><span class="doc">     * string at or after position {@code fromIndex}, then</span></li><li><span class="doc">     * {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * There is no restriction on the value of {@code fromIndex}. If it</span></li><li><span class="doc">     * is negative, it has the same effect as if it were zero: this entire</span></li><li><span class="doc">     * string may be searched. If it is greater than the length of this</span></li><li><span class="doc">     * string, it has the same effect as if it were equal to the length of</span></li><li><span class="doc">     * this string: {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;All indices are specified in {@code char} values</span></li><li><span class="doc">     * (Unicode code units).</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   ch          a character (Unicode code point).</span></li><li><span class="doc">     * @param   fromIndex   the index to start the search from.</span></li><li><span class="doc">     * @return  the index of the first occurrence of the character in the</span></li><li><span class="doc">     *          character sequence represented by this object that is greater</span></li><li><span class="doc">     *          than or equal to {@code fromIndex}, or {@code -1}</span></li><li><span class="doc">     *          if the character does not occur.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> indexOf<span class="bracket">(</span><span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">final</span> <span class="keyword">int</span> max = value.length;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>fromIndex <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            fromIndex = <span class="number">0</span>;</li><li>        <span class="bracket">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="bracket">(</span>fromIndex <span class="bracket">></span>= max<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="comment">// Note: fromIndex might be near -1&gt;&gt;&gt;1.</span></li><li>            <span class="keyword">return</span> -<span class="number">1</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>ch <span class="bracket"><</span> <span class="builtin_func">Character</span>.MIN_SUPPLEMENTARY_CODE_POINT<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="comment">// handle most cases here (ch is a BMP code point or a</span></li><li>            <span class="comment">// negative value (invalid code point))</span></li><li>            <span class="keyword">final</span> <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> value = <span class="keyword">this</span>.value;</li><li>            <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = fromIndex; i <span class="bracket"><</span> max; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>value<span class="bracket">[</span>i<span class="bracket">]</span> == ch<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">return</span> i;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> -<span class="number">1</span>;</li><li>        <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> indexOfSupplementary<span class="bracket">(</span>ch, fromIndex<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Handles (rare) calls of indexOf with a supplementary character.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">private</span> <span class="keyword">int</span> indexOfSupplementary<span class="bracket">(</span><span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="builtin_func">Character</span>.isValidCodePoint<span class="bracket">(</span>ch<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">final</span> <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> value = <span class="keyword">this</span>.value;</li><li>            <span class="keyword">final</span> <span class="keyword">char</span> hi = <span class="builtin_func">Character</span>.highSurrogate<span class="bracket">(</span>ch<span class="bracket">)</span>;</li><li>            <span class="keyword">final</span> <span class="keyword">char</span> lo = <span class="builtin_func">Character</span>.lowSurrogate<span class="bracket">(</span>ch<span class="bracket">)</span>;</li><li>            <span class="keyword">final</span> <span class="keyword">int</span> max = value.length - <span class="number">1</span>;</li><li>            <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = fromIndex; i <span class="bracket"><</span> max; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>value<span class="bracket">[</span>i<span class="bracket">]</span> == hi && value<span class="bracket">[</span>i + <span class="number">1</span><span class="bracket">]</span> == lo<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">return</span> i;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> -<span class="number">1</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the last occurrence of</span></li><li><span class="doc">     * the specified character. For values of {@code ch} in the</span></li><li><span class="doc">     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code</span></li><li><span class="doc">     * units) returned is the largest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. For other values of {@code ch}, it is the</span></li><li><span class="doc">     * largest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true.  In either case, if no such character occurs in this</span></li><li><span class="doc">     * string, then {@code -1} is returned.  The</span></li><li><span class="doc">     * {@code String} is searched backwards starting at the last</span></li><li><span class="doc">     * character.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   ch   a character (Unicode code point).</span></li><li><span class="doc">     * @return  the index of the last occurrence of the character in the</span></li><li><span class="doc">     *          character sequence represented by this object, or</span></li><li><span class="doc">     *          {@code -1} if the character does not occur.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> lastIndexOf<span class="bracket">(</span><span class="keyword">int</span> ch<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> lastIndexOf<span class="bracket">(</span>ch, value.length - <span class="number">1</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the last occurrence of</span></li><li><span class="doc">     * the specified character, searching backward starting at the</span></li><li><span class="doc">     * specified index. For values of {@code ch} in the range</span></li><li><span class="doc">     * from 0 to 0xFFFF (inclusive), the index returned is the largest</span></li><li><span class="doc">     * value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * (this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch) {@code &amp;&amp;} (&lt;i&gt;k&lt;/i&gt; &amp;lt;= fromIndex)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. For other values of {@code ch}, it is the</span></li><li><span class="doc">     * largest value &lt;i&gt;k&lt;/i&gt; such that:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * (this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch) {@code &amp;&amp;} (&lt;i&gt;k&lt;/i&gt; &amp;lt;= fromIndex)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * is true. In either case, if no such character occurs in this</span></li><li><span class="doc">     * string at or before position {@code fromIndex}, then</span></li><li><span class="doc">     * {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;All indices are specified in {@code char} values</span></li><li><span class="doc">     * (Unicode code units).</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   ch          a character (Unicode code point).</span></li><li><span class="doc">     * @param   fromIndex   the index to start the search from. There is no</span></li><li><span class="doc">     *          restriction on the value of {@code fromIndex}. If it is</span></li><li><span class="doc">     *          greater than or equal to the length of this string, it has</span></li><li><span class="doc">     *          the same effect as if it were equal to one less than the</span></li><li><span class="doc">     *          length of this string: this entire string may be searched.</span></li><li><span class="doc">     *          If it is negative, it has the same effect as if it were -1:</span></li><li><span class="doc">     *          -1 is returned.</span></li><li><span class="doc">     * @return  the index of the last occurrence of the character in the</span></li><li><span class="doc">     *          character sequence represented by this object that is less</span></li><li><span class="doc">     *          than or equal to {@code fromIndex}, or {@code -1}</span></li><li><span class="doc">     *          if the character does not occur before that point.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> lastIndexOf<span class="bracket">(</span><span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>ch <span class="bracket"><</span> <span class="builtin_func">Character</span>.MIN_SUPPLEMENTARY_CODE_POINT<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="comment">// handle most cases here (ch is a BMP code point or a</span></li><li>            <span class="comment">// negative value (invalid code point))</span></li><li>            <span class="keyword">final</span> <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> value = <span class="keyword">this</span>.value;</li><li>            <span class="keyword">int</span> i = <span class="builtin_func">Math</span>.min<span class="bracket">(</span>fromIndex, value.length - <span class="number">1</span><span class="bracket">)</span>;</li><li>            <span class="keyword">for</span> <span class="bracket">(</span>; i <span class="bracket">></span>= <span class="number">0</span>; i--<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>value<span class="bracket">[</span>i<span class="bracket">]</span> == ch<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">return</span> i;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> -<span class="number">1</span>;</li><li>        <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> lastIndexOfSupplementary<span class="bracket">(</span>ch, fromIndex<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Handles (rare) calls of lastIndexOf with a supplementary character.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">private</span> <span class="keyword">int</span> lastIndexOfSupplementary<span class="bracket">(</span><span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="builtin_func">Character</span>.isValidCodePoint<span class="bracket">(</span>ch<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">final</span> <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> value = <span class="keyword">this</span>.value;</li><li>            <span class="keyword">char</span> hi = <span class="builtin_func">Character</span>.highSurrogate<span class="bracket">(</span>ch<span class="bracket">)</span>;</li><li>            <span class="keyword">char</span> lo = <span class="builtin_func">Character</span>.lowSurrogate<span class="bracket">(</span>ch<span class="bracket">)</span>;</li><li>            <span class="keyword">int</span> i = <span class="builtin_func">Math</span>.min<span class="bracket">(</span>fromIndex, value.length - <span class="number">2</span><span class="bracket">)</span>;</li><li>            <span class="keyword">for</span> <span class="bracket">(</span>; i <span class="bracket">></span>= <span class="number">0</span>; i--<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>value<span class="bracket">[</span>i<span class="bracket">]</span> == hi && value<span class="bracket">[</span>i + <span class="number">1</span><span class="bracket">]</span> == lo<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">return</span> i;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> -<span class="number">1</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the first occurrence of the</span></li><li><span class="doc">     * specified substring.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   str   the substring to search for.</span></li><li><span class="doc">     * @return  the index of the first occurrence of the specified substring,</span></li><li><span class="doc">     *          or {@code -1} if there is no such occurrence.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> indexOf<span class="bracket">(</span><span class="builtin_func">String</span> str<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> indexOf<span class="bracket">(</span>str, <span class="number">0</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the first occurrence of the</span></li><li><span class="doc">     * specified substring, starting at the specified index.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * &lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex {@code &amp;&amp;} this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   str         the substring to search for.</span></li><li><span class="doc">     * @param   fromIndex   the index from which to start the search.</span></li><li><span class="doc">     * @return  the index of the first occurrence of the specified substring,</span></li><li><span class="doc">     *          starting at the specified index,</span></li><li><span class="doc">     *          or {@code -1} if there is no such occurrence.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> indexOf<span class="bracket">(</span><span class="builtin_func">String</span> str, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> indexOf<span class="bracket">(</span>value, <span class="number">0</span>, value.length,</li><li>                str.value, <span class="number">0</span>, str.value.length, fromIndex<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Code shared by String and AbstractStringBuilder to do searches. The</span></li><li><span class="doc">     * source is the character array being searched, and the target</span></li><li><span class="doc">     * is the string being searched for.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   source       the characters being searched.</span></li><li><span class="doc">     * @param   sourceOffset offset of the source string.</span></li><li><span class="doc">     * @param   sourceCount  count of the source string.</span></li><li><span class="doc">     * @param   target       the characters being searched for.</span></li><li><span class="doc">     * @param   fromIndex    the index to begin searching from.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">static</span> <span class="keyword">int</span> indexOf<span class="bracket">(</span><span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</li><li>            <span class="builtin_func">String</span> target, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> indexOf<span class="bracket">(</span>source, sourceOffset, sourceCount,</li><li>                       target.value, <span class="number">0</span>, target.value.length,</li><li>                       fromIndex<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Code shared by String and StringBuffer to do searches. The</span></li><li><span class="doc">     * source is the character array being searched, and the target</span></li><li><span class="doc">     * is the string being searched for.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   source       the characters being searched.</span></li><li><span class="doc">     * @param   sourceOffset offset of the source string.</span></li><li><span class="doc">     * @param   sourceCount  count of the source string.</span></li><li><span class="doc">     * @param   target       the characters being searched for.</span></li><li><span class="doc">     * @param   targetOffset offset of the target string.</span></li><li><span class="doc">     * @param   targetCount  count of the target string.</span></li><li><span class="doc">     * @param   fromIndex    the index to begin searching from.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">static</span> <span class="keyword">int</span> indexOf<span class="bracket">(</span><span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</li><li>            <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</li><li>            <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>fromIndex <span class="bracket">></span>= sourceCount<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="bracket">(</span>targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>fromIndex <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            fromIndex = <span class="number">0</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>targetCount == <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> fromIndex;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">char</span> first = target<span class="bracket">[</span>targetOffset<span class="bracket">]</span>;</li><li>        <span class="keyword">int</span> max = sourceOffset + <span class="bracket">(</span>sourceCount - targetCount<span class="bracket">)</span>;</li><li></li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = sourceOffset + fromIndex; i <span class="bracket"><</span>= max; i++<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="comment">/* Look for first character. */</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>source<span class="bracket">[</span>i<span class="bracket">]</span> != first<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">while</span> <span class="bracket">(</span>++i <span class="bracket"><</span>= max && source<span class="bracket">[</span>i<span class="bracket">]</span> != first<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li></li><li>            <span class="comment">/* Found first character, now look at the rest of v2 */</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>i <span class="bracket"><</span>= max<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">int</span> j = i + <span class="number">1</span>;</li><li>                <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</li><li>                <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j <span class="bracket"><</span> end && source<span class="bracket">[</span>j<span class="bracket">]</span></li><li>                        == target<span class="bracket">[</span>k<span class="bracket">]</span>; j++, k++<span class="bracket">)</span>;</li><li></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>j == end<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="comment">/* Found whole string. */</span></li><li>                    <span class="keyword">return</span> i - sourceOffset;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> -<span class="number">1</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the last occurrence of the</span></li><li><span class="doc">     * specified substring.  The last occurrence of the empty string &quot;&quot;</span></li><li><span class="doc">     * is considered to occur at the index value {@code this.length()}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   str   the substring to search for.</span></li><li><span class="doc">     * @return  the index of the last occurrence of the specified substring,</span></li><li><span class="doc">     *          or {@code -1} if there is no such occurrence.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> lastIndexOf<span class="bracket">(</span><span class="builtin_func">String</span> str<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> lastIndexOf<span class="bracket">(</span>str, value.length<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the index within this string of the last occurrence of the</span></li><li><span class="doc">     * specified substring, searching backward starting at the specified index.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * &lt;i&gt;k&lt;/i&gt; {@code &lt;=} fromIndex {@code &amp;&amp;} this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then {@code -1} is returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   str         the substring to search for.</span></li><li><span class="doc">     * @param   fromIndex   the index to start the search from.</span></li><li><span class="doc">     * @return  the index of the last occurrence of the specified substring,</span></li><li><span class="doc">     *          searching backward from the specified index,</span></li><li><span class="doc">     *          or {@code -1} if there is no such occurrence.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">int</span> lastIndexOf<span class="bracket">(</span><span class="builtin_func">String</span> str, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> lastIndexOf<span class="bracket">(</span>value, <span class="number">0</span>, value.length,</li><li>                str.value, <span class="number">0</span>, str.value.length, fromIndex<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Code shared by String and AbstractStringBuilder to do searches. The</span></li><li><span class="doc">     * source is the character array being searched, and the target</span></li><li><span class="doc">     * is the string being searched for.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   source       the characters being searched.</span></li><li><span class="doc">     * @param   sourceOffset offset of the source string.</span></li><li><span class="doc">     * @param   sourceCount  count of the source string.</span></li><li><span class="doc">     * @param   target       the characters being searched for.</span></li><li><span class="doc">     * @param   fromIndex    the index to begin searching from.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">static</span> <span class="keyword">int</span> lastIndexOf<span class="bracket">(</span><span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</li><li>            <span class="builtin_func">String</span> target, <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> lastIndexOf<span class="bracket">(</span>source, sourceOffset, sourceCount,</li><li>                       target.value, <span class="number">0</span>, target.value.length,</li><li>                       fromIndex<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Code shared by String and StringBuffer to do searches. The</span></li><li><span class="doc">     * source is the character array being searched, and the target</span></li><li><span class="doc">     * is the string being searched for.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   source       the characters being searched.</span></li><li><span class="doc">     * @param   sourceOffset offset of the source string.</span></li><li><span class="doc">     * @param   sourceCount  count of the source string.</span></li><li><span class="doc">     * @param   target       the characters being searched for.</span></li><li><span class="doc">     * @param   targetOffset offset of the target string.</span></li><li><span class="doc">     * @param   targetCount  count of the target string.</span></li><li><span class="doc">     * @param   fromIndex    the index to begin searching from.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">static</span> <span class="keyword">int</span> lastIndexOf<span class="bracket">(</span><span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</li><li>            <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</li><li>            <span class="keyword">int</span> fromIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="comment">/*</span></li><li><span class="comment">         * Check arguments; return immediately where possible. For</span></li><li><span class="comment">         * consistency, don't check for null str.</span></li><li><span class="comment">         */</span></li><li>        <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>fromIndex <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> -<span class="number">1</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>fromIndex <span class="bracket">></span> rightIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>            fromIndex = rightIndex;</li><li>        <span class="bracket">}</span></li><li>        <span class="comment">/* Empty string always matches. */</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>targetCount == <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> fromIndex;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</li><li>        <span class="keyword">char</span> strLastChar = target<span class="bracket">[</span>strLastIndex<span class="bracket">]</span>;</li><li>        <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</li><li>        <span class="keyword">int</span> i = min + fromIndex;</li><li></li><li>    startSearchForLastChar:</li><li>        <span class="keyword">while</span> <span class="bracket">(</span><span class="keyword">true</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">while</span> <span class="bracket">(</span>i <span class="bracket">></span>= min && source<span class="bracket">[</span>i<span class="bracket">]</span> != strLastChar<span class="bracket">)</span> <span class="bracket">{</span></li><li>                i--;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>i <span class="bracket"><</span> min<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">return</span> -<span class="number">1</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">int</span> j = i - <span class="number">1</span>;</li><li>            <span class="keyword">int</span> start = j - <span class="bracket">(</span>targetCount - <span class="number">1</span><span class="bracket">)</span>;</li><li>            <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</li><li></li><li>            <span class="keyword">while</span> <span class="bracket">(</span>j <span class="bracket">></span> start<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>source<span class="bracket">[</span>j--<span class="bracket">]</span> != target<span class="bracket">[</span>k--<span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    i--;</li><li>                    <span class="keyword">continue</span> startSearchForLastChar;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</li><li>        <span class="bracket">}</span></li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a string that is a substring of this string. The</span></li><li><span class="doc">     * substring begins with the character at the specified index and</span></li><li><span class="doc">     * extends to the end of this string. &lt;p&gt;</span></li><li><span class="doc">     * Examples:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * &quot;unhappy&quot;.substring(2) returns &quot;happy&quot;</span></li><li><span class="doc">     * &quot;Harbison&quot;.substring(3) returns &quot;bison&quot;</span></li><li><span class="doc">     * &quot;emptiness&quot;.substring(9) returns &quot;&quot; (an empty string)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param      beginIndex   the beginning index, inclusive.</span></li><li><span class="doc">     * @return     the specified substring.</span></li><li><span class="doc">     * @exception  IndexOutOfBoundsException  if</span></li><li><span class="doc">     *             {@code beginIndex} is negative or larger than the</span></li><li><span class="doc">     *             length of this {@code String} object.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> substring<span class="bracket">(</span><span class="keyword">int</span> beginIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>beginIndex <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>beginIndex<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">int</span> subLen = value.length - beginIndex;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>subLen <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>subLen<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="bracket">(</span>beginIndex == <span class="number">0</span><span class="bracket">)</span> ? <span class="keyword">this</span> : <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>value, beginIndex, subLen<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a string that is a substring of this string. The</span></li><li><span class="doc">     * substring begins at the specified {@code beginIndex} and</span></li><li><span class="doc">     * extends to the character at index {@code endIndex - 1}.</span></li><li><span class="doc">     * Thus the length of the substring is {@code endIndex-beginIndex}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Examples:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span></li><li><span class="doc">     * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param      beginIndex   the beginning index, inclusive.</span></li><li><span class="doc">     * @param      endIndex     the ending index, exclusive.</span></li><li><span class="doc">     * @return     the specified substring.</span></li><li><span class="doc">     * @exception  IndexOutOfBoundsException  if the</span></li><li><span class="doc">     *             {@code beginIndex} is negative, or</span></li><li><span class="doc">     *             {@code endIndex} is larger than the length of</span></li><li><span class="doc">     *             this {@code String} object, or</span></li><li><span class="doc">     *             {@code beginIndex} is larger than</span></li><li><span class="doc">     *             {@code endIndex}.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> substring<span class="bracket">(</span><span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>beginIndex <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>beginIndex<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>endIndex <span class="bracket">></span> value.length<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>endIndex<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">int</span> subLen = endIndex - beginIndex;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>subLen <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException<span class="bracket">(</span>subLen<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="bracket">(</span><span class="bracket">(</span>beginIndex == <span class="number">0</span><span class="bracket">)</span> && <span class="bracket">(</span>endIndex == value.length<span class="bracket">)</span><span class="bracket">)</span> ? <span class="keyword">this</span></li><li>                : <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>value, beginIndex, subLen<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a character sequence that is a subsequence of this sequence.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; An invocation of this method of the form</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * str.subSequence(begin,&amp;nbsp;end)&lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * behaves in exactly the same way as the invocation</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * str.substring(begin,&amp;nbsp;end)&lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @apiNote</span></li><li><span class="doc">     * This method is defined so that the {@code String} class can implement</span></li><li><span class="doc">     * the {@link CharSequence} interface.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   beginIndex   the begin index, inclusive.</span></li><li><span class="doc">     * @param   endIndex     the end index, exclusive.</span></li><li><span class="doc">     * @return  the specified subsequence.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  IndexOutOfBoundsException</span></li><li><span class="doc">     *          if {@code beginIndex} or {@code endIndex} is negative,</span></li><li><span class="doc">     *          if {@code endIndex} is greater than {@code length()},</span></li><li><span class="doc">     *          or if {@code beginIndex} is greater than {@code endIndex}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.4</span></li><li><span class="doc">     * @spec JSR-51</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> CharSequence subSequence<span class="bracket">(</span><span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">this</span>.substring<span class="bracket">(</span>beginIndex, endIndex<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Concatenates the specified string to the end of this string.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * If the length of the argument string is {@code 0}, then this</span></li><li><span class="doc">     * {@code String} object is returned. Otherwise, a</span></li><li><span class="doc">     * {@code String} object is returned that represents a character</span></li><li><span class="doc">     * sequence that is the concatenation of the character sequence</span></li><li><span class="doc">     * represented by this {@code String} object and the character</span></li><li><span class="doc">     * sequence represented by the argument string.&lt;p&gt;</span></li><li><span class="doc">     * Examples:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot;</span></li><li><span class="doc">     * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot;</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   str   the {@code String} that is concatenated to the end</span></li><li><span class="doc">     *                of this {@code String}.</span></li><li><span class="doc">     * @return  a string that represents the concatenation of this object's</span></li><li><span class="doc">     *          characters followed by the string argument's characters.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> concat<span class="bracket">(</span><span class="builtin_func">String</span> str<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">int</span> otherLen = str.length<span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span>otherLen == <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">return</span> <span class="keyword">this</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">int</span> len = value.length;</li><li>        <span class="keyword">char</span> buf<span class="bracket">[</span><span class="bracket">]</span> = <span class="builtin_func">Arrays</span>.copyOf<span class="bracket">(</span>value, len + otherLen<span class="bracket">)</span>;</li><li>        str.getChars<span class="bracket">(</span>buf, len<span class="bracket">)</span>;</li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>buf, <span class="keyword">true</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a string resulting from replacing all occurrences of</span></li><li><span class="doc">     * {@code oldChar} in this string with {@code newChar}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * If the character {@code oldChar} does not occur in the</span></li><li><span class="doc">     * character sequence represented by this {@code String} object,</span></li><li><span class="doc">     * then a reference to this {@code String} object is returned.</span></li><li><span class="doc">     * Otherwise, a {@code String} object is returned that</span></li><li><span class="doc">     * represents a character sequence identical to the character sequence</span></li><li><span class="doc">     * represented by this {@code String} object, except that every</span></li><li><span class="doc">     * occurrence of {@code oldChar} is replaced by an occurrence</span></li><li><span class="doc">     * of {@code newChar}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Examples:</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;pre&gt;</span></li><li><span class="doc">     * &quot;mesquite in your cellar&quot;.replace('e', 'o')</span></li><li><span class="doc">     *         returns &quot;mosquito in your collar&quot;</span></li><li><span class="doc">     * &quot;the war of baronets&quot;.replace('r', 'y')</span></li><li><span class="doc">     *         returns &quot;the way of bayonets&quot;</span></li><li><span class="doc">     * &quot;sparring with a purple porpoise&quot;.replace('p', 't')</span></li><li><span class="doc">     *         returns &quot;starring with a turtle tortoise&quot;</span></li><li><span class="doc">     * &quot;JonL&quot;.replace('q', 'x') returns &quot;JonL&quot; (no change)</span></li><li><span class="doc">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   oldChar   the old character.</span></li><li><span class="doc">     * @param   newChar   the new character.</span></li><li><span class="doc">     * @return  a string derived from this string by replacing every</span></li><li><span class="doc">     *          occurrence of {@code oldChar} with {@code newChar}.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> replace<span class="bracket">(</span><span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>oldChar != newChar<span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">int</span> len = value.length;</li><li>            <span class="keyword">int</span> i = -<span class="number">1</span>;</li><li>            <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> val = value; <span class="comment">/* avoid getfield opcode */</span></li><li></li><li>            <span class="keyword">while</span> <span class="bracket">(</span>++i <span class="bracket"><</span> len<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>val<span class="bracket">[</span>i<span class="bracket">]</span> == oldChar<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">break</span>;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>i <span class="bracket"><</span> len<span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">char</span> buf<span class="bracket">[</span><span class="bracket">]</span> = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>len<span class="bracket">]</span>;</li><li>                <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> j = <span class="number">0</span>; j <span class="bracket"><</span> i; j++<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    buf<span class="bracket">[</span>j<span class="bracket">]</span> = val<span class="bracket">[</span>j<span class="bracket">]</span>;</li><li>                <span class="bracket">}</span></li><li>                <span class="keyword">while</span> <span class="bracket">(</span>i <span class="bracket"><</span> len<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">char</span> c = val<span class="bracket">[</span>i<span class="bracket">]</span>;</li><li>                    buf<span class="bracket">[</span>i<span class="bracket">]</span> = <span class="bracket">(</span>c == oldChar<span class="bracket">)</span> ? newChar : c;</li><li>                    i++;</li><li>                <span class="bracket">}</span></li><li>                <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>buf, <span class="keyword">true</span><span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">this</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Tells whether or not this string matches the given &lt;a</span></li><li><span class="doc">     * href=&quot;../util/regex/Pattern.html&#35;sum&quot;&gt;regular expression&lt;/a&gt;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; An invocation of this method of the form</span></li><li><span class="doc">     * &lt;i&gt;str&lt;/i&gt;{@code .matches(}&lt;i&gt;regex&lt;/i&gt;{@code )} yields exactly the</span></li><li><span class="doc">     * same result as the expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;</span></li><li><span class="doc">     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern&#35;matches(String,CharSequence)</span></li><li><span class="doc">     * matches(&lt;i&gt;regex&lt;/i&gt;, &lt;i&gt;str&lt;/i&gt;)}</span></li><li><span class="doc">     * &lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   regex</span></li><li><span class="doc">     *          the regular expression to which this string is to be matched</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  {@code true} if, and only if, this string matches the</span></li><li><span class="doc">     *          given regular expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  PatternSyntaxException</span></li><li><span class="doc">     *          if the regular expression's syntax is invalid</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see java.util.regex.Pattern</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.4</span></li><li><span class="doc">     * @spec JSR-51</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> matches<span class="bracket">(</span><span class="builtin_func">String</span> regex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> Pattern.matches<span class="bracket">(</span>regex, <span class="keyword">this</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns true if and only if this string contains the specified</span></li><li><span class="doc">     * sequence of char values.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param s the sequence to search for</span></li><li><span class="doc">     * @return true if this string contains {@code s}, false otherwise</span></li><li><span class="doc">     * @since 1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> contains<span class="bracket">(</span>CharSequence s<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> indexOf<span class="bracket">(</span>s.toString<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">></span> -<span class="number">1</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Replaces the first substring of this string that matches the given &lt;a</span></li><li><span class="doc">     * href=&quot;../util/regex/Pattern.html&#35;sum&quot;&gt;regular expression&lt;/a&gt; with the</span></li><li><span class="doc">     * given replacement.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; An invocation of this method of the form</span></li><li><span class="doc">     * &lt;i&gt;str&lt;/i&gt;{@code .replaceFirst(}&lt;i&gt;regex&lt;/i&gt;{@code ,} &lt;i&gt;repl&lt;/i&gt;{@code )}</span></li><li><span class="doc">     * yields exactly the same result as the expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;</span></li><li><span class="doc">     * &lt;code&gt;</span></li><li><span class="doc">     * {@link java.util.regex.Pattern}.{@link</span></li><li><span class="doc">     * java.util.regex.Pattern&#35;compile compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span></li><li><span class="doc">     * java.util.regex.Pattern&#35;matcher(java.lang.CharSequence) matcher}(&lt;i&gt;str&lt;/i&gt;).{@link</span></li><li><span class="doc">     * java.util.regex.Matcher&#35;replaceFirst replaceFirst}(&lt;i&gt;repl&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/code&gt;</span></li><li><span class="doc">     * &lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     *&lt;p&gt;</span></li><li><span class="doc">     * Note that backslashes ({@code \}) and dollar signs ({@code $}) in the</span></li><li><span class="doc">     * replacement string may cause the results to be different than if it were</span></li><li><span class="doc">     * being treated as a literal replacement string; see</span></li><li><span class="doc">     * {@link java.util.regex.Matcher&#35;replaceFirst}.</span></li><li><span class="doc">     * Use {@link java.util.regex.Matcher&#35;quoteReplacement} to suppress the special</span></li><li><span class="doc">     * meaning of these characters, if desired.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   regex</span></li><li><span class="doc">     *          the regular expression to which this string is to be matched</span></li><li><span class="doc">     * @param   replacement</span></li><li><span class="doc">     *          the string to be substituted for the first match</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  The resulting {@code String}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  PatternSyntaxException</span></li><li><span class="doc">     *          if the regular expression's syntax is invalid</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see java.util.regex.Pattern</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.4</span></li><li><span class="doc">     * @spec JSR-51</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> replaceFirst<span class="bracket">(</span><span class="builtin_func">String</span> regex, <span class="builtin_func">String</span> replacement<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> Pattern.compile<span class="bracket">(</span>regex<span class="bracket">)</span>.matcher<span class="bracket">(</span><span class="keyword">this</span><span class="bracket">)</span>.replaceFirst<span class="bracket">(</span>replacement<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Replaces each substring of this string that matches the given &lt;a</span></li><li><span class="doc">     * href=&quot;../util/regex/Pattern.html&#35;sum&quot;&gt;regular expression&lt;/a&gt; with the</span></li><li><span class="doc">     * given replacement.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; An invocation of this method of the form</span></li><li><span class="doc">     * &lt;i&gt;str&lt;/i&gt;{@code .replaceAll(}&lt;i&gt;regex&lt;/i&gt;{@code ,} &lt;i&gt;repl&lt;/i&gt;{@code )}</span></li><li><span class="doc">     * yields exactly the same result as the expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;</span></li><li><span class="doc">     * &lt;code&gt;</span></li><li><span class="doc">     * {@link java.util.regex.Pattern}.{@link</span></li><li><span class="doc">     * java.util.regex.Pattern&#35;compile compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span></li><li><span class="doc">     * java.util.regex.Pattern&#35;matcher(java.lang.CharSequence) matcher}(&lt;i&gt;str&lt;/i&gt;).{@link</span></li><li><span class="doc">     * java.util.regex.Matcher&#35;replaceAll replaceAll}(&lt;i&gt;repl&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/code&gt;</span></li><li><span class="doc">     * &lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     *&lt;p&gt;</span></li><li><span class="doc">     * Note that backslashes ({@code \}) and dollar signs ({@code $}) in the</span></li><li><span class="doc">     * replacement string may cause the results to be different than if it were</span></li><li><span class="doc">     * being treated as a literal replacement string; see</span></li><li><span class="doc">     * {@link java.util.regex.Matcher&#35;replaceAll Matcher.replaceAll}.</span></li><li><span class="doc">     * Use {@link java.util.regex.Matcher&#35;quoteReplacement} to suppress the special</span></li><li><span class="doc">     * meaning of these characters, if desired.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   regex</span></li><li><span class="doc">     *          the regular expression to which this string is to be matched</span></li><li><span class="doc">     * @param   replacement</span></li><li><span class="doc">     *          the string to be substituted for each match</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  The resulting {@code String}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  PatternSyntaxException</span></li><li><span class="doc">     *          if the regular expression's syntax is invalid</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see java.util.regex.Pattern</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.4</span></li><li><span class="doc">     * @spec JSR-51</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> replaceAll<span class="bracket">(</span><span class="builtin_func">String</span> regex, <span class="builtin_func">String</span> replacement<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> Pattern.compile<span class="bracket">(</span>regex<span class="bracket">)</span>.matcher<span class="bracket">(</span><span class="keyword">this</span><span class="bracket">)</span>.replaceAll<span class="bracket">(</span>replacement<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Replaces each substring of this string that matches the literal target</span></li><li><span class="doc">     * sequence with the specified literal replacement sequence. The</span></li><li><span class="doc">     * replacement proceeds from the beginning of the string to the end, for</span></li><li><span class="doc">     * example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in</span></li><li><span class="doc">     * &quot;ba&quot; rather than &quot;ab&quot;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  target The sequence of char values to be replaced</span></li><li><span class="doc">     * @param  replacement The replacement sequence of char values</span></li><li><span class="doc">     * @return  The resulting string</span></li><li><span class="doc">     * @since 1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> replace<span class="bracket">(</span>CharSequence target, CharSequence replacement<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> Pattern.compile<span class="bracket">(</span>target.toString<span class="bracket">(</span><span class="bracket">)</span>, Pattern.LITERAL<span class="bracket">)</span>.matcher<span class="bracket">(</span></li><li>                <span class="keyword">this</span><span class="bracket">)</span>.replaceAll<span class="bracket">(</span>Matcher.quoteReplacement<span class="bracket">(</span>replacement.toString<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Splits this string around matches of the given</span></li><li><span class="doc">     * &lt;a href=&quot;../util/regex/Pattern.html&#35;sum&quot;&gt;regular expression&lt;/a&gt;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The array returned by this method contains each substring of this</span></li><li><span class="doc">     * string that is terminated by another substring that matches the given</span></li><li><span class="doc">     * expression or is terminated by the end of the string.  The substrings in</span></li><li><span class="doc">     * the array are in the order in which they occur in this string.  If the</span></li><li><span class="doc">     * expression does not match any part of the input then the resulting array</span></li><li><span class="doc">     * has just one element, namely this string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; When there is a positive-width match at the beginning of this</span></li><li><span class="doc">     * string then an empty leading substring is included at the beginning</span></li><li><span class="doc">     * of the resulting array. A zero-width match at the beginning however</span></li><li><span class="doc">     * never produces such empty leading substring.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The {@code limit} parameter controls the number of times the</span></li><li><span class="doc">     * pattern is applied and therefore affects the length of the resulting</span></li><li><span class="doc">     * array.  If the limit &lt;i&gt;n&lt;/i&gt; is greater than zero then the pattern</span></li><li><span class="doc">     * will be applied at most &lt;i&gt;n&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1 times, the array's</span></li><li><span class="doc">     * length will be no greater than &lt;i&gt;n&lt;/i&gt;, and the array's last entry</span></li><li><span class="doc">     * will contain all input beyond the last matched delimiter.  If &lt;i&gt;n&lt;/i&gt;</span></li><li><span class="doc">     * is non-positive then the pattern will be applied as many times as</span></li><li><span class="doc">     * possible and the array can have any length.  If &lt;i&gt;n&lt;/i&gt; is zero then</span></li><li><span class="doc">     * the pattern will be applied as many times as possible, the array can</span></li><li><span class="doc">     * have any length, and trailing empty strings will be discarded.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The string {@code &quot;boo:and:foo&quot;}, for example, yields the</span></li><li><span class="doc">     * following results with these parameters:</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0 summary=&quot;Split example showing regex, limit, and result&quot;&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *     &lt;th&gt;Regex&lt;/th&gt;</span></li><li><span class="doc">     *     &lt;th&gt;Limit&lt;/th&gt;</span></li><li><span class="doc">     *     &lt;th&gt;Result&lt;/th&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td align=center&gt;2&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and:foo&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td align=center&gt;5&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td align=center&gt;-2&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td align=center&gt;5&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td align=center&gt;-2&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td align=center&gt;0&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;/table&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; An invocation of this method of the form</span></li><li><span class="doc">     * &lt;i&gt;str.&lt;/i&gt;{@code split(}&lt;i&gt;regex&lt;/i&gt;{@code ,}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;{@code )}</span></li><li><span class="doc">     * yields the same result as the expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;</span></li><li><span class="doc">     * &lt;code&gt;</span></li><li><span class="doc">     * {@link java.util.regex.Pattern}.{@link</span></li><li><span class="doc">     * java.util.regex.Pattern&#35;compile compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span></li><li><span class="doc">     * java.util.regex.Pattern&#35;split(java.lang.CharSequence,int) split}(&lt;i&gt;str&lt;/i&gt;,&amp;nbsp;&lt;i&gt;n&lt;/i&gt;)</span></li><li><span class="doc">     * &lt;/code&gt;</span></li><li><span class="doc">     * &lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  regex</span></li><li><span class="doc">     *         the delimiting regular expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  limit</span></li><li><span class="doc">     *         the result threshold, as described above</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  the array of strings computed by splitting this string</span></li><li><span class="doc">     *          around matches of the given regular expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  PatternSyntaxException</span></li><li><span class="doc">     *          if the regular expression's syntax is invalid</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see java.util.regex.Pattern</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.4</span></li><li><span class="doc">     * @spec JSR-51</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">[</span><span class="bracket">]</span> split<span class="bracket">(</span><span class="builtin_func">String</span> regex, <span class="keyword">int</span> limit<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="comment">/* fastpath if the regex is a</span></li><li><span class="comment">         (1)one-char String and this character is not one of the</span></li><li><span class="comment">            RegEx's meta characters &quot;.$|()[{^?*+\\&quot;, or</span></li><li><span class="comment">         (2)two-char String and the first char is the backslash and</span></li><li><span class="comment">            the second is not the ascii digit or ascii letter.</span></li><li><span class="comment">         */</span></li><li>        <span class="keyword">char</span> ch = <span class="number">0</span>;</li><li>        <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span><span class="bracket">(</span>regex.value.length == <span class="number">1</span> &&</li><li>             <span class="string">&quot;.$|()[{^?*+\\&quot;</span>.indexOf<span class="bracket">(</span>ch = regex.charAt<span class="bracket">(</span><span class="number">0</span><span class="bracket">)</span><span class="bracket">)</span> == -<span class="number">1</span><span class="bracket">)</span> ||</li><li>             <span class="bracket">(</span>regex.length<span class="bracket">(</span><span class="bracket">)</span> == <span class="number">2</span> &&</li><li>              regex.charAt<span class="bracket">(</span><span class="number">0</span><span class="bracket">)</span> == <span class="character">'\\'</span> &&</li><li>              <span class="bracket">(</span><span class="bracket">(</span><span class="bracket">(</span>ch = regex.charAt<span class="bracket">(</span><span class="number">1</span><span class="bracket">)</span><span class="bracket">)</span>-<span class="character">'0'</span><span class="bracket">)</span>|<span class="bracket">(</span><span class="character">'9'</span>-ch<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket"><</span> <span class="number">0</span> &&</li><li>              <span class="bracket">(</span><span class="bracket">(</span>ch-<span class="character">'a'</span><span class="bracket">)</span>|<span class="bracket">(</span><span class="character">'z'</span>-ch<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket"><</span> <span class="number">0</span> &&</li><li>              <span class="bracket">(</span><span class="bracket">(</span>ch-<span class="character">'A'</span><span class="bracket">)</span>|<span class="bracket">(</span><span class="character">'Z'</span>-ch<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket"><</span> <span class="number">0</span><span class="bracket">)</span><span class="bracket">)</span> &&</li><li>            <span class="bracket">(</span>ch <span class="bracket"><</span> <span class="builtin_func">Character</span>.MIN_HIGH_SURROGATE ||</li><li>             ch <span class="bracket">></span> <span class="builtin_func">Character</span>.MAX_LOW_SURROGATE<span class="bracket">)</span><span class="bracket">)</span></li><li>        <span class="bracket">{</span></li><li>            <span class="keyword">int</span> off = <span class="number">0</span>;</li><li>            <span class="keyword">int</span> next = <span class="number">0</span>;</li><li>            <span class="keyword">boolean</span> limited = limit <span class="bracket">></span> <span class="number">0</span>;</li><li>            <span class="builtin_func">ArrayList</span><span class="bracket"><</span><span class="builtin_func">String</span><span class="bracket">></span> list = <span class="keyword">new</span> <span class="builtin_func">ArrayList</span><span class="bracket"><</span><span class="bracket">></span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>            <span class="keyword">while</span> <span class="bracket">(</span><span class="bracket">(</span>next = indexOf<span class="bracket">(</span>ch, off<span class="bracket">)</span><span class="bracket">)</span> != -<span class="number">1</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>!limited || list.size<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket"><</span> limit - <span class="number">1</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    list.add<span class="bracket">(</span>substring<span class="bracket">(</span>off, next<span class="bracket">)</span><span class="bracket">)</span>;</li><li>                    off = next + <span class="number">1</span>;</li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span>    <span class="comment">// last one</span></li><li>                    <span class="comment">//assert (list.size() == limit - 1);</span></li><li>                    list.add<span class="bracket">(</span>substring<span class="bracket">(</span>off, value.length<span class="bracket">)</span><span class="bracket">)</span>;</li><li>                    off = value.length;</li><li>                    <span class="keyword">break</span>;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="comment">// If no match was found, return this</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>off == <span class="number">0</span><span class="bracket">)</span></li><li>                <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">[</span><span class="bracket">]</span><span class="bracket">{</span><span class="keyword">this</span><span class="bracket">}</span>;</li><li></li><li>            <span class="comment">// Add remaining segment</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>!limited || list.size<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket"><</span> limit<span class="bracket">)</span></li><li>                list.add<span class="bracket">(</span>substring<span class="bracket">(</span>off, value.length<span class="bracket">)</span><span class="bracket">)</span>;</li><li></li><li>            <span class="comment">// Construct result</span></li><li>            <span class="keyword">int</span> resultSize = list.size<span class="bracket">(</span><span class="bracket">)</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span>limit == <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">while</span> <span class="bracket">(</span>resultSize <span class="bracket">></span> <span class="number">0</span> && list.get<span class="bracket">(</span>resultSize - <span class="number">1</span><span class="bracket">)</span>.length<span class="bracket">(</span><span class="bracket">)</span> == <span class="number">0</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    resultSize--;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="builtin_func">String</span><span class="bracket">[</span><span class="bracket">]</span> result = <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">[</span>resultSize<span class="bracket">]</span>;</li><li>            <span class="keyword">return</span> list.subList<span class="bracket">(</span><span class="number">0</span>, resultSize<span class="bracket">)</span>.toArray<span class="bracket">(</span>result<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> Pattern.compile<span class="bracket">(</span>regex<span class="bracket">)</span>.split<span class="bracket">(</span><span class="keyword">this</span>, limit<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Splits this string around matches of the given &lt;a</span></li><li><span class="doc">     * href=&quot;../util/regex/Pattern.html&#35;sum&quot;&gt;regular expression&lt;/a&gt;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; This method works as if by invoking the two-argument {@link</span></li><li><span class="doc">     * &#35;split(String, int) split} method with the given expression and a limit</span></li><li><span class="doc">     * argument of zero.  Trailing empty strings are therefore not included in</span></li><li><span class="doc">     * the resulting array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The string {@code &quot;boo:and:foo&quot;}, for example, yields the following</span></li><li><span class="doc">     * results with these expressions:</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0 summary=&quot;Split examples showing regex and result&quot;&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *  &lt;th&gt;Regex&lt;/th&gt;</span></li><li><span class="doc">     *  &lt;th&gt;Result&lt;/th&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;</span></li><li><span class="doc">     *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;</span></li><li><span class="doc">     * &lt;/table&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  regex</span></li><li><span class="doc">     *         the delimiting regular expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  the array of strings computed by splitting this string</span></li><li><span class="doc">     *          around matches of the given regular expression</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  PatternSyntaxException</span></li><li><span class="doc">     *          if the regular expression's syntax is invalid</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see java.util.regex.Pattern</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @since 1.4</span></li><li><span class="doc">     * @spec JSR-51</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span><span class="bracket">[</span><span class="bracket">]</span> split<span class="bracket">(</span><span class="builtin_func">String</span> regex<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> split<span class="bracket">(</span>regex, <span class="number">0</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a new String composed of copies of the</span></li><li><span class="doc">     * {@code CharSequence elements} joined together with a copy of</span></li><li><span class="doc">     * the specified {@code delimiter}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;For example,</span></li><li><span class="doc">     * &lt;pre&gt;{@code</span></li><li><span class="doc">     *     String message = String.join(&quot;-&quot;, &quot;Java&quot;, &quot;is&quot;, &quot;cool&quot;);</span></li><li><span class="doc">     *     // message returned is: &quot;Java-is-cool&quot;</span></li><li><span class="doc">     * }&lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * Note that if an element is null, then {@code &quot;null&quot;} is added.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  delimiter the delimiter that separates each element</span></li><li><span class="doc">     * @param  elements the elements to join together.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return a new {@code String} that is composed of the {@code elements}</span></li><li><span class="doc">     *         separated by the {@code delimiter}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws NullPointerException If {@code delimiter} or {@code elements}</span></li><li><span class="doc">     *         is {@code null}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see java.util.StringJoiner</span></li><li><span class="doc">     * @since 1.8</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> join<span class="bracket">(</span>CharSequence delimiter, CharSequence... elements<span class="bracket">)</span> <span class="bracket">{</span></li><li>        Objects.requireNonNull<span class="bracket">(</span>delimiter<span class="bracket">)</span>;</li><li>        Objects.requireNonNull<span class="bracket">(</span>elements<span class="bracket">)</span>;</li><li>        <span class="comment">// Number of elements not likely worth Arrays.stream overhead.</span></li><li>        StringJoiner joiner = <span class="keyword">new</span> StringJoiner<span class="bracket">(</span>delimiter<span class="bracket">)</span>;</li><li>        <span class="keyword">for</span> <span class="bracket">(</span>CharSequence cs: elements<span class="bracket">)</span> <span class="bracket">{</span></li><li>            joiner.add<span class="bracket">(</span>cs<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> joiner.toString<span class="bracket">(</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a new {@code String} composed of copies of the</span></li><li><span class="doc">     * {@code CharSequence elements} joined together with a copy of the</span></li><li><span class="doc">     * specified {@code delimiter}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;blockquote&gt;For example,</span></li><li><span class="doc">     * &lt;pre&gt;{@code</span></li><li><span class="doc">     *     List&lt;String&gt; strings = new LinkedList&lt;&gt;();</span></li><li><span class="doc">     *     strings.add(&quot;Java&quot;);strings.add(&quot;is&quot;);</span></li><li><span class="doc">     *     strings.add(&quot;cool&quot;);</span></li><li><span class="doc">     *     String message = String.join(&quot; &quot;, strings);</span></li><li><span class="doc">     *     //message returned is: &quot;Java is cool&quot;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     *     Set&lt;String&gt; strings = new LinkedHashSet&lt;&gt;();</span></li><li><span class="doc">     *     strings.add(&quot;Java&quot;); strings.add(&quot;is&quot;);</span></li><li><span class="doc">     *     strings.add(&quot;very&quot;); strings.add(&quot;cool&quot;);</span></li><li><span class="doc">     *     String message = String.join(&quot;-&quot;, strings);</span></li><li><span class="doc">     *     //message returned is: &quot;Java-is-very-cool&quot;</span></li><li><span class="doc">     * }&lt;/pre&gt;&lt;/blockquote&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * Note that if an individual element is {@code null}, then {@code &quot;null&quot;} is added.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  delimiter a sequence of characters that is used to separate each</span></li><li><span class="doc">     *         of the {@code elements} in the resulting {@code String}</span></li><li><span class="doc">     * @param  elements an {@code Iterable} that will have its {@code elements}</span></li><li><span class="doc">     *         joined together.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return a new {@code String} that is composed from the {@code elements}</span></li><li><span class="doc">     *         argument</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws NullPointerException If {@code delimiter} or {@code elements}</span></li><li><span class="doc">     *         is {@code null}</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see    &#35;join(CharSequence,CharSequence...)</span></li><li><span class="doc">     * @see    java.util.StringJoiner</span></li><li><span class="doc">     * @since 1.8</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> join<span class="bracket">(</span>CharSequence delimiter,</li><li>            Iterable<span class="bracket"><</span>? <span class="keyword">extends</span> CharSequence<span class="bracket">></span> elements<span class="bracket">)</span> <span class="bracket">{</span></li><li>        Objects.requireNonNull<span class="bracket">(</span>delimiter<span class="bracket">)</span>;</li><li>        Objects.requireNonNull<span class="bracket">(</span>elements<span class="bracket">)</span>;</li><li>        StringJoiner joiner = <span class="keyword">new</span> StringJoiner<span class="bracket">(</span>delimiter<span class="bracket">)</span>;</li><li>        <span class="keyword">for</span> <span class="bracket">(</span>CharSequence cs: elements<span class="bracket">)</span> <span class="bracket">{</span></li><li>            joiner.add<span class="bracket">(</span>cs<span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> joiner.toString<span class="bracket">(</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Converts all of the characters in this {@code String} to lower</span></li><li><span class="doc">     * case using the rules of the given {@code Locale}.  Case mapping is based</span></li><li><span class="doc">     * on the Unicode Standard version specified by the {@link java.lang.Character Character}</span></li><li><span class="doc">     * class. Since case mappings are not always 1:1 char mappings, the resulting</span></li><li><span class="doc">     * {@code String} may be a different length than the original {@code String}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Examples of lowercase  mappings are in the following table:</span></li><li><span class="doc">     * &lt;table border=&quot;1&quot; summary=&quot;Lowercase mapping examples showing language code of locale, upper case, lower case, and description&quot;&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Language Code of Locale&lt;/th&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Upper Case&lt;/th&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Lower Case&lt;/th&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Description&lt;/th&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;tr (Turkish)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0130&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0069&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;capital letter I with dot above -&amp;gt; small letter i&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;tr (Turkish)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0049&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0131&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;capital letter I -&amp;gt; small letter dotless i &lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;(all)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;French Fries&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;french fries&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;lowercased all chars in String&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;(all)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&lt;img src=&quot;doc-files/capiota.gif&quot; alt=&quot;capiota&quot;&gt;&lt;img src=&quot;doc-files/capchi.gif&quot; alt=&quot;capchi&quot;&gt;</span></li><li><span class="doc">     *       &lt;img src=&quot;doc-files/captheta.gif&quot; alt=&quot;captheta&quot;&gt;&lt;img src=&quot;doc-files/capupsil.gif&quot; alt=&quot;capupsil&quot;&gt;</span></li><li><span class="doc">     *       &lt;img src=&quot;doc-files/capsigma.gif&quot; alt=&quot;capsigma&quot;&gt;&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&lt;img src=&quot;doc-files/iota.gif&quot; alt=&quot;iota&quot;&gt;&lt;img src=&quot;doc-files/chi.gif&quot; alt=&quot;chi&quot;&gt;</span></li><li><span class="doc">     *       &lt;img src=&quot;doc-files/theta.gif&quot; alt=&quot;theta&quot;&gt;&lt;img src=&quot;doc-files/upsilon.gif&quot; alt=&quot;upsilon&quot;&gt;</span></li><li><span class="doc">     *       &lt;img src=&quot;doc-files/sigma1.gif&quot; alt=&quot;sigma&quot;&gt;&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;lowercased all chars in String&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;/table&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param locale use the case transformation rules for this locale</span></li><li><span class="doc">     * @return the {@code String}, converted to lowercase.</span></li><li><span class="doc">     * @see     java.lang.String&#35;toLowerCase()</span></li><li><span class="doc">     * @see     java.lang.String&#35;toUpperCase()</span></li><li><span class="doc">     * @see     java.lang.String&#35;toUpperCase(Locale)</span></li><li><span class="doc">     * @since   1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> toLowerCase<span class="bracket">(</span>Locale locale<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>locale == <span class="keyword">null</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">NullPointerException</span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">int</span> firstUpper;</li><li>        <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</li><li></li><li>        <span class="comment">/* Now check if there are any characters that need to be changed. */</span></li><li>        scan: <span class="bracket">{</span></li><li>            <span class="keyword">for</span> <span class="bracket">(</span>firstUpper = <span class="number">0</span> ; firstUpper <span class="bracket"><</span> len; <span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">char</span> c = value<span class="bracket">[</span>firstUpper<span class="bracket">]</span>;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>c <span class="bracket">></span>= <span class="builtin_func">Character</span>.MIN_HIGH_SURROGATE<span class="bracket">)</span></li><li>                        && <span class="bracket">(</span>c <span class="bracket"><</span>= <span class="builtin_func">Character</span>.MAX_HIGH_SURROGATE<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">int</span> supplChar = codePointAt<span class="bracket">(</span>firstUpper<span class="bracket">)</span>;</li><li>                    <span class="keyword">if</span> <span class="bracket">(</span>supplChar != <span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>supplChar<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                        <span class="keyword">break</span> scan;</li><li>                    <span class="bracket">}</span></li><li>                    firstUpper += <span class="builtin_func">Character</span>.charCount<span class="bracket">(</span>supplChar<span class="bracket">)</span>;</li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                    <span class="keyword">if</span> <span class="bracket">(</span>c != <span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>c<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                        <span class="keyword">break</span> scan;</li><li>                    <span class="bracket">}</span></li><li>                    firstUpper++;</li><li>                <span class="bracket">}</span></li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> <span class="keyword">this</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> result = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>len<span class="bracket">]</span>;</li><li>        <span class="keyword">int</span> resultOffset = <span class="number">0</span>;  <span class="comment">/* result may grow, so i+resultOffset</span></li><li><span class="comment">                                * is the write location in result */</span></li><li></li><li>        <span class="comment">/* Just copy the first few lowerCase characters. */</span></li><li>        <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>value, <span class="number">0</span>, result, <span class="number">0</span>, firstUpper<span class="bracket">)</span>;</li><li></li><li>        <span class="builtin_func">String</span> lang = locale.getLanguage<span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="keyword">boolean</span> localeDependent =</li><li>                <span class="bracket">(</span>lang == <span class="string">&quot;tr&quot;</span> || lang == <span class="string">&quot;az&quot;</span> || lang == <span class="string">&quot;lt&quot;</span><span class="bracket">)</span>;</li><li>        <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> lowerCharArray;</li><li>        <span class="keyword">int</span> lowerChar;</li><li>        <span class="keyword">int</span> srcChar;</li><li>        <span class="keyword">int</span> srcCount;</li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = firstUpper; i <span class="bracket"><</span> len; i += srcCount<span class="bracket">)</span> <span class="bracket">{</span></li><li>            srcChar = <span class="bracket">(</span><span class="keyword">int</span><span class="bracket">)</span>value<span class="bracket">[</span>i<span class="bracket">]</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>srcChar <span class="bracket">></span>= <span class="builtin_func">Character</span>.MIN_HIGH_SURROGATE</li><li>                    && <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>srcChar <span class="bracket"><</span>= <span class="builtin_func">Character</span>.MAX_HIGH_SURROGATE<span class="bracket">)</span> <span class="bracket">{</span></li><li>                srcChar = codePointAt<span class="bracket">(</span>i<span class="bracket">)</span>;</li><li>                srcCount = <span class="builtin_func">Character</span>.charCount<span class="bracket">(</span>srcChar<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                srcCount = <span class="number">1</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>localeDependent ||</li><li>                srcChar == <span class="character">'\u03A3'</span> || <span class="comment">// GREEK CAPITAL LETTER SIGMA</span></li><li>                srcChar == <span class="character">'\u0130'</span><span class="bracket">)</span> <span class="bracket">{</span> <span class="comment">// LATIN CAPITAL LETTER I WITH DOT ABOVE</span></li><li>                lowerChar = ConditionalSpecialCasing.toLowerCaseEx<span class="bracket">(</span><span class="keyword">this</span>, i, locale<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                lowerChar = <span class="builtin_func">Character</span>.toLowerCase<span class="bracket">(</span>srcChar<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>lowerChar == <span class="builtin_func">Character</span>.ERROR<span class="bracket">)</span></li><li>                    || <span class="bracket">(</span>lowerChar <span class="bracket">></span>= <span class="builtin_func">Character</span>.MIN_SUPPLEMENTARY_CODE_POINT<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>lowerChar == <span class="builtin_func">Character</span>.ERROR<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    lowerCharArray =</li><li>                            ConditionalSpecialCasing.toLowerCaseCharArray<span class="bracket">(</span><span class="keyword">this</span>, i, locale<span class="bracket">)</span>;</li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="bracket">(</span>srcCount == <span class="number">2</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    resultOffset += <span class="builtin_func">Character</span>.toChars<span class="bracket">(</span>lowerChar, result, i + resultOffset<span class="bracket">)</span> - srcCount;</li><li>                    <span class="keyword">continue</span>;</li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                    lowerCharArray = <span class="builtin_func">Character</span>.toChars<span class="bracket">(</span>lowerChar<span class="bracket">)</span>;</li><li>                <span class="bracket">}</span></li><li></li><li>                <span class="comment">/* Grow result if needed */</span></li><li>                <span class="keyword">int</span> mapLen = lowerCharArray.length;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span>mapLen <span class="bracket">></span> srcCount<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> result2 = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>result.length + mapLen - srcCount<span class="bracket">]</span>;</li><li>                    <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset<span class="bracket">)</span>;</li><li>                    result = result2;</li><li>                <span class="bracket">}</span></li><li>                <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> x = <span class="number">0</span>; x <span class="bracket"><</span> mapLen; ++x<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    result<span class="bracket">[</span>i + resultOffset + x<span class="bracket">]</span> = lowerCharArray<span class="bracket">[</span>x<span class="bracket">]</span>;</li><li>                <span class="bracket">}</span></li><li>                resultOffset += <span class="bracket">(</span>mapLen - srcCount<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                result<span class="bracket">[</span>i + resultOffset<span class="bracket">]</span> = <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>lowerChar;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>result, <span class="number">0</span>, len + resultOffset<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Converts all of the characters in this {@code String} to lower</span></li><li><span class="doc">     * case using the rules of the default locale. This is equivalent to calling</span></li><li><span class="doc">     * {@code toLowerCase(Locale.getDefault())}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * &lt;b&gt;Note:&lt;/b&gt; This method is locale sensitive, and may produce unexpected</span></li><li><span class="doc">     * results if used for strings that are intended to be interpreted locale</span></li><li><span class="doc">     * independently.</span></li><li><span class="doc">     * Examples are programming language identifiers, protocol keys, and HTML</span></li><li><span class="doc">     * tags.</span></li><li><span class="doc">     * For instance, {@code &quot;TITLE&quot;.toLowerCase()} in a Turkish locale</span></li><li><span class="doc">     * returns {@code &quot;t\u005Cu0131tle&quot;}, where '\u005Cu0131' is the</span></li><li><span class="doc">     * LATIN SMALL LETTER DOTLESS I character.</span></li><li><span class="doc">     * To obtain correct results for locale insensitive strings, use</span></li><li><span class="doc">     * {@code toLowerCase(Locale.ROOT)}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * @return  the {@code String}, converted to lowercase.</span></li><li><span class="doc">     * @see     java.lang.String&#35;toLowerCase(Locale)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> toLowerCase<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> toLowerCase<span class="bracket">(</span>Locale.getDefault<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Converts all of the characters in this {@code String} to upper</span></li><li><span class="doc">     * case using the rules of the given {@code Locale}. Case mapping is based</span></li><li><span class="doc">     * on the Unicode Standard version specified by the {@link java.lang.Character Character}</span></li><li><span class="doc">     * class. Since case mappings are not always 1:1 char mappings, the resulting</span></li><li><span class="doc">     * {@code String} may be a different length than the original {@code String}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Examples of locale-sensitive and 1:M case mappings are in the following table.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;table border=&quot;1&quot; summary=&quot;Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.&quot;&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Language Code of Locale&lt;/th&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Lower Case&lt;/th&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Upper Case&lt;/th&gt;</span></li><li><span class="doc">     *   &lt;th&gt;Description&lt;/th&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;tr (Turkish)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0069&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0130&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;small letter i -&amp;gt; capital letter I with dot above&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;tr (Turkish)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0131&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0049&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;small letter dotless i -&amp;gt; capital letter I&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;(all)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u00df&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&amp;&#35;92;u0053 &amp;&#35;92;u0053&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;small letter sharp s -&amp;gt; two letters: SS&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;tr&gt;</span></li><li><span class="doc">     *   &lt;td&gt;(all)&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;Fahrvergn&amp;uuml;gen&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;FAHRVERGN&amp;Uuml;GEN&lt;/td&gt;</span></li><li><span class="doc">     *   &lt;td&gt;&lt;/td&gt;</span></li><li><span class="doc">     * &lt;/tr&gt;</span></li><li><span class="doc">     * &lt;/table&gt;</span></li><li><span class="doc">     * @param locale use the case transformation rules for this locale</span></li><li><span class="doc">     * @return the {@code String}, converted to uppercase.</span></li><li><span class="doc">     * @see     java.lang.String&#35;toUpperCase()</span></li><li><span class="doc">     * @see     java.lang.String&#35;toLowerCase()</span></li><li><span class="doc">     * @see     java.lang.String&#35;toLowerCase(Locale)</span></li><li><span class="doc">     * @since   1.1</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> toUpperCase<span class="bracket">(</span>Locale locale<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">if</span> <span class="bracket">(</span>locale == <span class="keyword">null</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="builtin_func">NullPointerException</span><span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="keyword">int</span> firstLower;</li><li>        <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</li><li></li><li>        <span class="comment">/* Now check if there are any characters that need to be changed. */</span></li><li>        scan: <span class="bracket">{</span></li><li>            <span class="keyword">for</span> <span class="bracket">(</span>firstLower = <span class="number">0</span> ; firstLower <span class="bracket"><</span> len; <span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">int</span> c = <span class="bracket">(</span><span class="keyword">int</span><span class="bracket">)</span>value<span class="bracket">[</span>firstLower<span class="bracket">]</span>;</li><li>                <span class="keyword">int</span> srcCount;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>c <span class="bracket">></span>= <span class="builtin_func">Character</span>.MIN_HIGH_SURROGATE<span class="bracket">)</span></li><li>                        && <span class="bracket">(</span>c <span class="bracket"><</span>= <span class="builtin_func">Character</span>.MAX_HIGH_SURROGATE<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    c = codePointAt<span class="bracket">(</span>firstLower<span class="bracket">)</span>;</li><li>                    srcCount = <span class="builtin_func">Character</span>.charCount<span class="bracket">(</span>c<span class="bracket">)</span>;</li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                    srcCount = <span class="number">1</span>;</li><li>                <span class="bracket">}</span></li><li>                <span class="keyword">int</span> upperCaseChar = <span class="builtin_func">Character</span>.toUpperCaseEx<span class="bracket">(</span>c<span class="bracket">)</span>;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>upperCaseChar == <span class="builtin_func">Character</span>.ERROR<span class="bracket">)</span></li><li>                        || <span class="bracket">(</span>c != upperCaseChar<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">break</span> scan;</li><li>                <span class="bracket">}</span></li><li>                firstLower += srcCount;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">return</span> <span class="keyword">this</span>;</li><li>        <span class="bracket">}</span></li><li></li><li>        <span class="comment">/* result may grow, so i+resultOffset is the write location in result */</span></li><li>        <span class="keyword">int</span> resultOffset = <span class="number">0</span>;</li><li>        <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> result = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>len<span class="bracket">]</span>; <span class="comment">/* may grow */</span></li><li></li><li>        <span class="comment">/* Just copy the first few upperCase characters. */</span></li><li>        <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>value, <span class="number">0</span>, result, <span class="number">0</span>, firstLower<span class="bracket">)</span>;</li><li></li><li>        <span class="builtin_func">String</span> lang = locale.getLanguage<span class="bracket">(</span><span class="bracket">)</span>;</li><li>        <span class="keyword">boolean</span> localeDependent =</li><li>                <span class="bracket">(</span>lang == <span class="string">&quot;tr&quot;</span> || lang == <span class="string">&quot;az&quot;</span> || lang == <span class="string">&quot;lt&quot;</span><span class="bracket">)</span>;</li><li>        <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> upperCharArray;</li><li>        <span class="keyword">int</span> upperChar;</li><li>        <span class="keyword">int</span> srcChar;</li><li>        <span class="keyword">int</span> srcCount;</li><li>        <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> i = firstLower; i <span class="bracket"><</span> len; i += srcCount<span class="bracket">)</span> <span class="bracket">{</span></li><li>            srcChar = <span class="bracket">(</span><span class="keyword">int</span><span class="bracket">)</span>value<span class="bracket">[</span>i<span class="bracket">]</span>;</li><li>            <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>srcChar <span class="bracket">></span>= <span class="builtin_func">Character</span>.MIN_HIGH_SURROGATE &&</li><li>                <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>srcChar <span class="bracket"><</span>= <span class="builtin_func">Character</span>.MAX_HIGH_SURROGATE<span class="bracket">)</span> <span class="bracket">{</span></li><li>                srcChar = codePointAt<span class="bracket">(</span>i<span class="bracket">)</span>;</li><li>                srcCount = <span class="builtin_func">Character</span>.charCount<span class="bracket">(</span>srcChar<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                srcCount = <span class="number">1</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span>localeDependent<span class="bracket">)</span> <span class="bracket">{</span></li><li>                upperChar = ConditionalSpecialCasing.toUpperCaseEx<span class="bracket">(</span><span class="keyword">this</span>, i, locale<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                upperChar = <span class="builtin_func">Character</span>.toUpperCaseEx<span class="bracket">(</span>srcChar<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span></li><li>            <span class="keyword">if</span> <span class="bracket">(</span><span class="bracket">(</span>upperChar == <span class="builtin_func">Character</span>.ERROR<span class="bracket">)</span></li><li>                    || <span class="bracket">(</span>upperChar <span class="bracket">></span>= <span class="builtin_func">Character</span>.MIN_SUPPLEMENTARY_CODE_POINT<span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                <span class="keyword">if</span> <span class="bracket">(</span>upperChar == <span class="builtin_func">Character</span>.ERROR<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">if</span> <span class="bracket">(</span>localeDependent<span class="bracket">)</span> <span class="bracket">{</span></li><li>                        upperCharArray =</li><li>                                ConditionalSpecialCasing.toUpperCaseCharArray<span class="bracket">(</span><span class="keyword">this</span>, i, locale<span class="bracket">)</span>;</li><li>                    <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                        upperCharArray = <span class="builtin_func">Character</span>.toUpperCaseCharArray<span class="bracket">(</span>srcChar<span class="bracket">)</span>;</li><li>                    <span class="bracket">}</span></li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="bracket">(</span>srcCount == <span class="number">2</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>                    resultOffset += <span class="builtin_func">Character</span>.toChars<span class="bracket">(</span>upperChar, result, i + resultOffset<span class="bracket">)</span> - srcCount;</li><li>                    <span class="keyword">continue</span>;</li><li>                <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                    upperCharArray = <span class="builtin_func">Character</span>.toChars<span class="bracket">(</span>upperChar<span class="bracket">)</span>;</li><li>                <span class="bracket">}</span></li><li></li><li>                <span class="comment">/* Grow result if needed */</span></li><li>                <span class="keyword">int</span> mapLen = upperCharArray.length;</li><li>                <span class="keyword">if</span> <span class="bracket">(</span>mapLen <span class="bracket">></span> srcCount<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> result2 = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>result.length + mapLen - srcCount<span class="bracket">]</span>;</li><li>                    <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset<span class="bracket">)</span>;</li><li>                    result = result2;</li><li>                <span class="bracket">}</span></li><li>                <span class="keyword">for</span> <span class="bracket">(</span><span class="keyword">int</span> x = <span class="number">0</span>; x <span class="bracket"><</span> mapLen; ++x<span class="bracket">)</span> <span class="bracket">{</span></li><li>                    result<span class="bracket">[</span>i + resultOffset + x<span class="bracket">]</span> = upperCharArray<span class="bracket">[</span>x<span class="bracket">]</span>;</li><li>                <span class="bracket">}</span></li><li>                resultOffset += <span class="bracket">(</span>mapLen - srcCount<span class="bracket">)</span>;</li><li>            <span class="bracket">}</span> <span class="keyword">else</span> <span class="bracket">{</span></li><li>                result<span class="bracket">[</span>i + resultOffset<span class="bracket">]</span> = <span class="bracket">(</span><span class="keyword">char</span><span class="bracket">)</span>upperChar;</li><li>            <span class="bracket">}</span></li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>result, <span class="number">0</span>, len + resultOffset<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Converts all of the characters in this {@code String} to upper</span></li><li><span class="doc">     * case using the rules of the default locale. This method is equivalent to</span></li><li><span class="doc">     * {@code toUpperCase(Locale.getDefault())}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * &lt;b&gt;Note:&lt;/b&gt; This method is locale sensitive, and may produce unexpected</span></li><li><span class="doc">     * results if used for strings that are intended to be interpreted locale</span></li><li><span class="doc">     * independently.</span></li><li><span class="doc">     * Examples are programming language identifiers, protocol keys, and HTML</span></li><li><span class="doc">     * tags.</span></li><li><span class="doc">     * For instance, {@code &quot;title&quot;.toUpperCase()} in a Turkish locale</span></li><li><span class="doc">     * returns {@code &quot;T\u005Cu0130TLE&quot;}, where '\u005Cu0130' is the</span></li><li><span class="doc">     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.</span></li><li><span class="doc">     * To obtain correct results for locale insensitive strings, use</span></li><li><span class="doc">     * {@code toUpperCase(Locale.ROOT)}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * @return  the {@code String}, converted to uppercase.</span></li><li><span class="doc">     * @see     java.lang.String&#35;toUpperCase(Locale)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> toUpperCase<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> toUpperCase<span class="bracket">(</span>Locale.getDefault<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a string whose value is this string, with any leading and trailing</span></li><li><span class="doc">     * whitespace removed.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * If this {@code String} object represents an empty character</span></li><li><span class="doc">     * sequence, or the first and last characters of character sequence</span></li><li><span class="doc">     * represented by this {@code String} object both have codes</span></li><li><span class="doc">     * greater than {@code '\u005Cu0020'} (the space character), then a</span></li><li><span class="doc">     * reference to this {@code String} object is returned.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Otherwise, if there is no character with a code greater than</span></li><li><span class="doc">     * {@code '\u005Cu0020'} in the string, then a</span></li><li><span class="doc">     * {@code String} object representing an empty string is</span></li><li><span class="doc">     * returned.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * Otherwise, let &lt;i&gt;k&lt;/i&gt; be the index of the first character in the</span></li><li><span class="doc">     * string whose code is greater than {@code '\u005Cu0020'}, and let</span></li><li><span class="doc">     * &lt;i&gt;m&lt;/i&gt; be the index of the last character in the string whose code</span></li><li><span class="doc">     * is greater than {@code '\u005Cu0020'}. A {@code String}</span></li><li><span class="doc">     * object is returned, representing the substring of this string that</span></li><li><span class="doc">     * begins with the character at index &lt;i&gt;k&lt;/i&gt; and ends with the</span></li><li><span class="doc">     * character at index &lt;i&gt;m&lt;/i&gt;-that is, the result of</span></li><li><span class="doc">     * {@code this.substring(k, m + 1)}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * This method may be used to trim whitespace (as defined above) from</span></li><li><span class="doc">     * the beginning and end of a string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  A string whose value is this string, with any leading and trailing white</span></li><li><span class="doc">     *          space removed, or this string if it has no leading or</span></li><li><span class="doc">     *          trailing white space.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> trim<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">int</span> len = value.length;</li><li>        <span class="keyword">int</span> st = <span class="number">0</span>;</li><li>        <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> val = value;    <span class="comment">/* avoid getfield opcode */</span></li><li></li><li>        <span class="keyword">while</span> <span class="bracket">(</span><span class="bracket">(</span>st <span class="bracket"><</span> len<span class="bracket">)</span> && <span class="bracket">(</span>val<span class="bracket">[</span>st<span class="bracket">]</span> <span class="bracket"><</span>= <span class="character">' '</span><span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            st++;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">while</span> <span class="bracket">(</span><span class="bracket">(</span>st <span class="bracket"><</span> len<span class="bracket">)</span> && <span class="bracket">(</span>val<span class="bracket">[</span>len - <span class="number">1</span><span class="bracket">]</span> <span class="bracket"><</span>= <span class="character">' '</span><span class="bracket">)</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>            len--;</li><li>        <span class="bracket">}</span></li><li>        <span class="keyword">return</span> <span class="bracket">(</span><span class="bracket">(</span>st <span class="bracket">></span> <span class="number">0</span><span class="bracket">)</span> || <span class="bracket">(</span>len <span class="bracket"><</span> value.length<span class="bracket">)</span><span class="bracket">)</span> ? substring<span class="bracket">(</span>st, len<span class="bracket">)</span> : <span class="keyword">this</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * This object (which is already a string!) is itself returned.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  the string itself.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="builtin_func">String</span> toString<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">this</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Converts this string to a new character array.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  a newly allocated character array whose length is the length</span></li><li><span class="doc">     *          of this string and whose contents are initialized to contain</span></li><li><span class="doc">     *          the character sequence represented by this string.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">char</span><span class="bracket">[</span><span class="bracket">]</span> toCharArray<span class="bracket">(</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></li><li>        <span class="keyword">char</span> result<span class="bracket">[</span><span class="bracket">]</span> = <span class="keyword">new</span> <span class="keyword">char</span><span class="bracket">[</span>value.length<span class="bracket">]</span>;</li><li>        <span class="builtin_func">System</span>.arraycopy<span class="bracket">(</span>value, <span class="number">0</span>, result, <span class="number">0</span>, value.length<span class="bracket">)</span>;</li><li>        <span class="keyword">return</span> result;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a formatted string using the specified format string and</span></li><li><span class="doc">     * arguments.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * &lt;p&gt; The locale always used is the one returned by {@link</span></li><li><span class="doc">     * java.util.Locale&#35;getDefault() Locale.getDefault()}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  format</span></li><li><span class="doc">     *         A &lt;a href=&quot;../util/Formatter.html&#35;syntax&quot;&gt;format string&lt;/a&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  args</span></li><li><span class="doc">     *         Arguments referenced by the format specifiers in the format</span></li><li><span class="doc">     *         string.  If there are more arguments than format specifiers, the</span></li><li><span class="doc">     *         extra arguments are ignored.  The number of arguments is</span></li><li><span class="doc">     *         variable and may be zero.  The maximum number of arguments is</span></li><li><span class="doc">     *         limited by the maximum dimension of a Java array as defined by</span></li><li><span class="doc">     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span></li><li><span class="doc">     *         The behaviour on a</span></li><li><span class="doc">     *         {@code null} argument depends on the &lt;a</span></li><li><span class="doc">     *         href=&quot;../util/Formatter.html&#35;syntax&quot;&gt;conversion&lt;/a&gt;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  java.util.IllegalFormatException</span></li><li><span class="doc">     *          If a format string contains an illegal syntax, a format</span></li><li><span class="doc">     *          specifier that is incompatible with the given arguments,</span></li><li><span class="doc">     *          insufficient arguments given the format string, or other</span></li><li><span class="doc">     *          illegal conditions.  For specification of all possible</span></li><li><span class="doc">     *          formatting errors, see the &lt;a</span></li><li><span class="doc">     *          href=&quot;../util/Formatter.html&#35;detail&quot;&gt;Details&lt;/a&gt; section of the</span></li><li><span class="doc">     *          formatter class specification.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  A formatted string</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see  java.util.Formatter</span></li><li><span class="doc">     * @since  1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> format<span class="bracket">(</span><span class="builtin_func">String</span> format, <span class="builtin_func">Object</span>... args<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> Formatter<span class="bracket">(</span><span class="bracket">)</span>.format<span class="bracket">(</span>format, args<span class="bracket">)</span>.toString<span class="bracket">(</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a formatted string using the specified locale, format string,</span></li><li><span class="doc">     * and arguments.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  l</span></li><li><span class="doc">     *         The {@linkplain java.util.Locale locale} to apply during</span></li><li><span class="doc">     *         formatting.  If {@code l} is {@code null} then no localization</span></li><li><span class="doc">     *         is applied.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  format</span></li><li><span class="doc">     *         A &lt;a href=&quot;../util/Formatter.html&#35;syntax&quot;&gt;format string&lt;/a&gt;</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param  args</span></li><li><span class="doc">     *         Arguments referenced by the format specifiers in the format</span></li><li><span class="doc">     *         string.  If there are more arguments than format specifiers, the</span></li><li><span class="doc">     *         extra arguments are ignored.  The number of arguments is</span></li><li><span class="doc">     *         variable and may be zero.  The maximum number of arguments is</span></li><li><span class="doc">     *         limited by the maximum dimension of a Java array as defined by</span></li><li><span class="doc">     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span></li><li><span class="doc">     *         The behaviour on a</span></li><li><span class="doc">     *         {@code null} argument depends on the</span></li><li><span class="doc">     *         &lt;a href=&quot;../util/Formatter.html&#35;syntax&quot;&gt;conversion&lt;/a&gt;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @throws  java.util.IllegalFormatException</span></li><li><span class="doc">     *          If a format string contains an illegal syntax, a format</span></li><li><span class="doc">     *          specifier that is incompatible with the given arguments,</span></li><li><span class="doc">     *          insufficient arguments given the format string, or other</span></li><li><span class="doc">     *          illegal conditions.  For specification of all possible</span></li><li><span class="doc">     *          formatting errors, see the &lt;a</span></li><li><span class="doc">     *          href=&quot;../util/Formatter.html&#35;detail&quot;&gt;Details&lt;/a&gt; section of the</span></li><li><span class="doc">     *          formatter class specification</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  A formatted string</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @see  java.util.Formatter</span></li><li><span class="doc">     * @since  1.5</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> format<span class="bracket">(</span>Locale l, <span class="builtin_func">String</span> format, <span class="builtin_func">Object</span>... args<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> Formatter<span class="bracket">(</span>l<span class="bracket">)</span>.format<span class="bracket">(</span>format, args<span class="bracket">)</span>.toString<span class="bracket">(</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code Object} argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   obj   an {@code Object}.</span></li><li><span class="doc">     * @return  if the argument is {@code null}, then a string equal to</span></li><li><span class="doc">     *          {@code &quot;null&quot;}; otherwise, the value of</span></li><li><span class="doc">     *          {@code obj.toString()} is returned.</span></li><li><span class="doc">     * @see     java.lang.Object&#35;toString()</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="builtin_func">Object</span> obj<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="bracket">(</span>obj == <span class="keyword">null</span><span class="bracket">)</span> ? <span class="string">&quot;null&quot;</span> : obj.toString<span class="bracket">(</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code char} array</span></li><li><span class="doc">     * argument. The contents of the character array are copied; subsequent</span></li><li><span class="doc">     * modification of the character array does not affect the returned</span></li><li><span class="doc">     * string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   data     the character array.</span></li><li><span class="doc">     * @return  a {@code String} that contains the characters of the</span></li><li><span class="doc">     *          character array.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">char</span> data<span class="bracket">[</span><span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>data<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of a specific subarray of the</span></li><li><span class="doc">     * {@code char} array argument.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * The {@code offset} argument is the index of the first</span></li><li><span class="doc">     * character of the subarray. The {@code count} argument</span></li><li><span class="doc">     * specifies the length of the subarray. The contents of the subarray</span></li><li><span class="doc">     * are copied; subsequent modification of the character array does not</span></li><li><span class="doc">     * affect the returned string.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   data     the character array.</span></li><li><span class="doc">     * @param   offset   initial offset of the subarray.</span></li><li><span class="doc">     * @param   count    length of the subarray.</span></li><li><span class="doc">     * @return  a {@code String} that contains the characters of the</span></li><li><span class="doc">     *          specified subarray of the character array.</span></li><li><span class="doc">     * @exception IndexOutOfBoundsException if {@code offset} is</span></li><li><span class="doc">     *          negative, or {@code count} is negative, or</span></li><li><span class="doc">     *          {@code offset+count} is larger than</span></li><li><span class="doc">     *          {@code data.length}.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">char</span> data<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> offset, <span class="keyword">int</span> count<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>data, offset, count<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Equivalent to {@link &#35;valueOf(char[], int, int)}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   data     the character array.</span></li><li><span class="doc">     * @param   offset   initial offset of the subarray.</span></li><li><span class="doc">     * @param   count    length of the subarray.</span></li><li><span class="doc">     * @return  a {@code String} that contains the characters of the</span></li><li><span class="doc">     *          specified subarray of the character array.</span></li><li><span class="doc">     * @exception IndexOutOfBoundsException if {@code offset} is</span></li><li><span class="doc">     *          negative, or {@code count} is negative, or</span></li><li><span class="doc">     *          {@code offset+count} is larger than</span></li><li><span class="doc">     *          {@code data.length}.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> copyValueOf<span class="bracket">(</span><span class="keyword">char</span> data<span class="bracket">[</span><span class="bracket">]</span>, <span class="keyword">int</span> offset, <span class="keyword">int</span> count<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>data, offset, count<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Equivalent to {@link &#35;valueOf(char[])}.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   data   the character array.</span></li><li><span class="doc">     * @return  a {@code String} that contains the characters of the</span></li><li><span class="doc">     *          character array.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> copyValueOf<span class="bracket">(</span><span class="keyword">char</span> data<span class="bracket">[</span><span class="bracket">]</span><span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>data<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code boolean} argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   b   a {@code boolean}.</span></li><li><span class="doc">     * @return  if the argument is {@code true}, a string equal to</span></li><li><span class="doc">     *          {@code &quot;true&quot;} is returned; otherwise, a string equal to</span></li><li><span class="doc">     *          {@code &quot;false&quot;} is returned.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">boolean</span> b<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> b ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code char}</span></li><li><span class="doc">     * argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   c   a {@code char}.</span></li><li><span class="doc">     * @return  a string of length {@code 1} containing</span></li><li><span class="doc">     *          as its single character the argument {@code c}.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">char</span> c<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">char</span> data<span class="bracket">[</span><span class="bracket">]</span> = <span class="bracket">{</span>c<span class="bracket">}</span>;</li><li>        <span class="keyword">return</span> <span class="keyword">new</span> <span class="builtin_func">String</span><span class="bracket">(</span>data, <span class="keyword">true</span><span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code int} argument.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * The representation is exactly the one returned by the</span></li><li><span class="doc">     * {@code Integer.toString} method of one argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   i   an {@code int}.</span></li><li><span class="doc">     * @return  a string representation of the {@code int} argument.</span></li><li><span class="doc">     * @see     java.lang.Integer&#35;toString(int, int)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">int</span> i<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Integer</span>.toString<span class="bracket">(</span>i<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code long} argument.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * The representation is exactly the one returned by the</span></li><li><span class="doc">     * {@code Long.toString} method of one argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   l   a {@code long}.</span></li><li><span class="doc">     * @return  a string representation of the {@code long} argument.</span></li><li><span class="doc">     * @see     java.lang.Long&#35;toString(long)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">long</span> l<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Long</span>.toString<span class="bracket">(</span>l<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code float} argument.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * The representation is exactly the one returned by the</span></li><li><span class="doc">     * {@code Float.toString} method of one argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   f   a {@code float}.</span></li><li><span class="doc">     * @return  a string representation of the {@code float} argument.</span></li><li><span class="doc">     * @see     java.lang.Float&#35;toString(float)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">float</span> f<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Float</span>.toString<span class="bracket">(</span>f<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns the string representation of the {@code double} argument.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * The representation is exactly the one returned by the</span></li><li><span class="doc">     * {@code Double.toString} method of one argument.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @param   d   a {@code double}.</span></li><li><span class="doc">     * @return  a  string representation of the {@code double} argument.</span></li><li><span class="doc">     * @see     java.lang.Double&#35;toString(double)</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="builtin_func">String</span> valueOf<span class="bracket">(</span><span class="keyword">double</span> d<span class="bracket">)</span> <span class="bracket">{</span></li><li>        <span class="keyword">return</span> <span class="builtin_func">Double</span>.toString<span class="bracket">(</span>d<span class="bracket">)</span>;</li><li>    <span class="bracket">}</span></li><li></li><li>    <span class="doc">/**</span></li><li><span class="doc">     * Returns a canonical representation for the string object.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * A pool of strings, initially empty, is maintained privately by the</span></li><li><span class="doc">     * class {@code String}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * When the intern method is invoked, if the pool already contains a</span></li><li><span class="doc">     * string equal to this {@code String} object as determined by</span></li><li><span class="doc">     * the {@link &#35;equals(Object)} method, then the string from the pool is</span></li><li><span class="doc">     * returned. Otherwise, this {@code String} object is added to the</span></li><li><span class="doc">     * pool and a reference to this {@code String} object is returned.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * It follows that for any two strings {@code s} and {@code t},</span></li><li><span class="doc">     * {@code s.intern() == t.intern()} is {@code true}</span></li><li><span class="doc">     * if and only if {@code s.equals(t)} is {@code true}.</span></li><li><span class="doc">     * &lt;p&gt;</span></li><li><span class="doc">     * All literal strings and string-valued constant expressions are</span></li><li><span class="doc">     * interned. String literals are defined in section 3.10.5 of the</span></li><li><span class="doc">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></li><li><span class="doc">     *</span></li><li><span class="doc">     * @return  a string that has the same contents as this string, but is</span></li><li><span class="doc">     *          guaranteed to be from a pool of unique strings.</span></li><li><span class="doc">     */</span></li><li>    <span class="keyword">public</span> <span class="keyword">native</span> <span class="builtin_func">String</span> intern<span class="bracket">(</span><span class="bracket">)</span>;</li><li><span class="bracket">}</span></li></ol></pre></fieldset></body></html>